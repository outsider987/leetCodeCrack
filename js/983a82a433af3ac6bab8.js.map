{"version":3,"file":"983a82a433af3ac6bab8.js","mappings":";;;;;;;;;;;;;;;;;;;AAA0B;AAC4D;AACtD;AACgB;AACzC;AACP,kEAAkE,khNAAW,SAAS,GAAG,QAAQ;AACjG,gBAAgB,mDAAY;AAC5B;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,gBAAgB,mDAAY;AAC5B,oBAAoB,khNAAW,SAAS,GAAG,QAAQ;AACnD,mBAAmB,oCAAoC;AACvD,KAAK;AACL;AACA,sBAAsB,+DAAe;AACrC;AACA,qDAAqD,kBAAkB;AACvE;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oCAAoC,+DAAe;AACnD;AACA,qCAAqC,iDAAU,IAAI,khNAAW,SAAS;AACvE;AACA,qBAAqB;AACrB;AACA,qDAAqD,yBAAyB;AAC9E,yBAAyB;AACzB,qBAAqB;AACrB,oBAAoB,+DAAe;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,iEAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,kDAAc,CAAC,6DAAc,GAAG,gEAAgE;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpFmC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,gDAAS;AAC7B,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA,aAAa;AACb,sBAAsB,iBAAiB;AACvC,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;AC/BgB;AACF;AACtC;AACP,YAAY,YAAY,EAAE,yDAAe;AACzC,kBAAkB,6DAAgB;AAClC;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;;;ACX8D;AACnB;AACS;AACpD;AACA,iBAAiB,6CAAM;AACvB,YAAY,kHAAkH,EAAE,iEAAiB;AACjJ,yBAAyB,6CAAM;AAC/B,IAAI,gDAAS;AACb;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,0DAAmB;AAC/B;AACA,6CAA6C,0DAAmB,UAAU,oCAAoC;AAC9G,gBAAgB,0DAAmB,UAAU,kBAAkB;AAC/D,QAAQ,0DAAmB,UAAU,iDAAiD;AACtF,YAAY,0DAAmB,CAAC,2DAAO,IAAI,gCAAgC;AAC3E;AACA;AACA,iEAAe,cAAc,EAAC","sources":["webpack://leetcodecrack/./src/api/base.ts","webpack://leetcodecrack/./src/api/randPost.ts","webpack://leetcodecrack/./src/data/randPost.ts","webpack://leetcodecrack/./src/pages/Home/Performance/InfiniteScroll.tsx"],"sourcesContent":["import axios from 'axios';\nimport { cleanTokenStorage, getTokenStorage, setTokenStorage } from '~/utils/storage';\nimport { store } from '~/store';\nimport { setAlertDialog } from '~/store/global';\nexport const publicApi = (subPath = '', isDummyData = false) => {\n    const url = isDummyData ? 'https://dummyapi.io/data/v1/' : `${process.env.API_URL}/${subPath}`;\n    const api = axios.create({\n        baseURL: url,\n        headers: {\n            'Content-Type': 'application/json',\n        },\n    });\n    api.interceptors.request.use((config) => {\n        return config;\n    }, (error) => {\n        return Promise.reject(error);\n    });\n    api.interceptors.response.use((response) => {\n        checkErrorCdoe(response);\n        return response;\n    }, (error) => {\n        if (error.response.status === 401)\n            return error.response;\n        checkErrorCdoe(error.response);\n        return error.response;\n    });\n    return api;\n};\nexport const privateApi = (subPath = '') => {\n    const api = axios.create({\n        baseURL: `${process.env.API_URL}/${subPath}`,\n        headers: { 'Content-Type': 'application/json' },\n    });\n    api.interceptors.request.use(async (config) => {\n        const token = getTokenStorage();\n        if (config.headers)\n            config.headers.authorization = `Bearer ${token.accessToken}`;\n        return config;\n    }, (error) => {\n        return Promise.reject(error);\n    });\n    api.interceptors.response.use(async (response) => {\n        checkErrorCdoe(response);\n        return response;\n    }, async (error) => {\n        if (error.response) {\n            // Access Token was expired\n            if (error.response.status === 401) {\n                const storedToken = getTokenStorage();\n                try {\n                    const rs = await axios.post(`${process.env.API_URL}/auth/refresh`, {\n                        refreshToken: storedToken.refreshToken,\n                    }, {\n                        headers: {\n                            authorization: `Bearer ${storedToken.refreshToken}`,\n                        },\n                    });\n                    setTokenStorage(rs.data.data);\n                    return api(error.config);\n                }\n                catch (_error) {\n                    console.log(_error);\n                    if (_error.response.status === 401) {\n                        cleanTokenStorage();\n                    }\n                    checkErrorCdoe(_error.response, _error.response.status);\n                    return Promise.reject(_error);\n                }\n            }\n        }\n        return Promise.reject(error);\n    });\n    return api;\n};\nasync function checkErrorCdoe(response, catchError = 'good') {\n    switch (response.data.status) {\n        case false:\n            store.dispatch(setAlertDialog({ show: true, msg: JSON.stringify(response.data), title: 'Error' }));\n            break;\n        case true:\n            break;\n        default:\n            break;\n    }\n}\n","import { publicApi } from './base';\nexport const PostDatasType = {\n    id: '60d21b4667d0d8992e610c85',\n    image: 'https://img.dummyapi.io/photo-1564694202779-bc908c327862.jpg',\n    likes: 43,\n    tags: ['animal', 'dog', 'golden retriever'],\n    text: 'adult Labrador retriever',\n    publishDate: '2020-05-24T14:53:17.598Z',\n    owner: {\n        id: '60d0fe4f5311236168a109ca',\n        title: 'ms',\n        firstName: 'Sara',\n        lastName: 'Andersen',\n        picture: 'https://randomuser.me/api/portraits/women/58.jpg',\n    },\n};\nconst subPath = 'post';\nconst useRandPostsApi = () => {\n    const postApi = publicApi(subPath);\n    const GET_POSTS = async ({ pageParam = 1 }) => {\n        const resp = await postApi.get('https://dummyapi.io/data/v1/post?limit=10', {\n            headers: {\n                'Content-Type': 'application/json',\n                'app-id': '637e288874c675dfd68d88e1',\n            },\n            params: { page: pageParam },\n        });\n        return resp.data.data;\n    };\n    return { GET_POSTS };\n};\nexport default useRandPostsApi;\n","import { useInfiniteQuery } from 'react-query';\nimport useRandPostsApi from '~/api/randPost';\nexport const useRandPostsDatas = (page) => {\n    const { GET_POSTS } = useRandPostsApi();\n    const Posts = useInfiniteQuery('post', GET_POSTS, {\n        getNextPageParam: (lastPage, allPages) => {\n            const nextPage = allPages.length + 1;\n            return nextPage;\n        },\n    });\n    return Posts;\n};\n","import React, { useCallback, useEffect, useRef } from 'react';\nimport SvgICon from '~/components/SvgIcon';\nimport { useRandPostsDatas } from '~/data/randPost';\nconst InfiniteScroll = () => {\n    const page = useRef(1);\n    const { data, isSuccess, isLoading, isFetchingNextPage, fetchNextPage, fetchPreviousPage, hasNextPage, hasPreviousPage, } = useRandPostsDatas(1);\n    const observerElem = useRef(null);\n    useEffect(() => {\n        let fetching = false;\n        const handleScroll = async (e) => {\n            const { scrollHeight, scrollTop, clientHeight } = e.target.scrollingElement;\n            if (!fetching && scrollHeight - scrollTop <= clientHeight * 1.2) {\n                fetching = true;\n                if (hasNextPage)\n                    await fetchNextPage();\n                fetching = false;\n            }\n        };\n        document.addEventListener('scroll', handleScroll);\n        return () => {\n            document.removeEventListener('scroll', handleScroll);\n        };\n    }, [fetchNextPage, hasNextPage]);\n    const handleObserver = useCallback((entries) => {\n        const [target] = entries;\n        if (target.isIntersecting) {\n            fetchNextPage();\n        }\n    }, [fetchNextPage, hasNextPage]);\n    useEffect(() => {\n        const element = observerElem.current;\n        const option = { threshold: 0 };\n        const observer = new IntersectionObserver(handleObserver, option);\n        observer.observe(element);\n        return () => observer.unobserve(element);\n    }, [fetchNextPage, hasNextPage, handleObserver]);\n    const len = data?.pages.length;\n    return (React.createElement(\"div\", null,\n        isSuccess &&\n            data.pages.flat().map((post) => (React.createElement(\"div\", { className: \"result\", key: post?.id },\n                React.createElement(\"img\", { src: post?.image })))),\n        React.createElement(\"div\", { className: \"flex text-white\", ref: observerElem },\n            React.createElement(SvgICon, { name: \"spin\", className: \"w-5\" }),\n            isFetchingNextPage && hasNextPage ? 'Loading...' : 'No search left')));\n};\nexport default InfiniteScroll;\n"],"names":[],"sourceRoot":""}