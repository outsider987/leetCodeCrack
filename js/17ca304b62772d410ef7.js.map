{"version":3,"file":"17ca304b62772d410ef7.js","mappings":";;;;;;;;;;;;;;;;;;;AAAgE;AACrB;AACY;AAC2B;AACnC;AACE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,0BAA0B,wDAAS;AACnC;AACA;AACA;AACA,cAAc,4DAAc;AAC5B,wBAAwB,8DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8DAAe;AACxD;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD,QAAQ,+EAAqB;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,4BAA4B;AAC5C,yCAAyC,6EAAmB;AAC5D;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,4BAA4B,wEAAc,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;AChHQ;AACD;AAC5B,8BAA8B,8CAAK;AACnC;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;ACrDF;AACD;AAC5B,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;ACfI;AAC7B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;ACXrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;ACVrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AChCyC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;AClEwC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;ACjEwC;AACpC;AACM;AACnC,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;ACpDS;AACA;AACJ;AACrB;AACP,aAAa;AACb,aAAa;AACb,WAAW;AACX;AACe;AACf;AACA","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Canvas/Canvas.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/BackgroundLayer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/FileLayer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/Layer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Point.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/BaselTool.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Brush.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Erase.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Pan.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/index.ts"],"sourcesContent":["import { getTransformedPoint } from '~/utils/canvas/coordinate';\nimport FileLayer from '../Layer/FileLayer';\nimport BackgroundLayer from '../Layer/BackgroundLayer';\nimport { getCurrentZoom, redrawBoundBackGround } from '~/utils/canvas/mainCanvas';\nimport { onload2promise } from '~/utils/image';\nimport { getNewSize } from '~/utils/canvas/rect';\nclass Views {\n    constructor() {\n        this.isDrawStart = false;\n        this.zoomLevel = 1;\n        this.lastView = null;\n        this.layerArray = [];\n        this.cameraOffsetX = 0;\n        this.cameraOffsetY = 0;\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n    }\n    initializeCanvas(canvas) {\n        // initialize canvas\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.width = canvas.width;\n        this.height = canvas.height;\n        this.bufferCanvas = document.createElement('canvas');\n        this.bufferCtx = this.bufferCanvas.getContext('2d');\n        this.zoomLevel = 0;\n        this.cameraOffsetX = 0;\n        this.cameraOffsetY = 0;\n        this.registerEvent(this.canvas);\n    }\n    async loadFile(file) {\n        const { bufferCanvas, bufferCtx, canvas, ctx } = this;\n        const layer = new FileLayer(bufferCanvas);\n        this.layerArray.push(layer);\n        const image = new Image();\n        image.src = URL.createObjectURL(file);\n        await onload2promise(image);\n        const newSize = getNewSize(canvas, image);\n        bufferCanvas.width = newSize.newWidth;\n        bufferCanvas.height = newSize.newHeight;\n        bufferCtx.clearRect(0, 0, canvas.width, canvas.height);\n        bufferCtx.fillStyle = 'black';\n        bufferCtx.fillRect(0, 0, canvas.width, canvas.height);\n        let ratio = Math.min(bufferCanvas.width / image.width, bufferCanvas.height / image.height);\n        let x = (bufferCanvas.width - image.width * ratio) / 2;\n        let y = (bufferCanvas.height - image.height * ratio) / 2;\n        bufferCtx.drawImage(image, 0, 0, image.width, image.height, x, y, image.width * ratio, image.height * ratio);\n        ctx.translate(canvas.width / 2, canvas.height / 2);\n        ctx.scale(0.5, 0.5);\n        ctx.translate(-canvas.width / 2, -canvas.height / 2);\n        ctx.transform(1, 0, 0, 1, (canvas.width - bufferCanvas.width) / 2, (canvas.height - bufferCanvas.height) / 2);\n        this.backgroundLayer = await new BackgroundLayer(this.bufferCanvas);\n        this.draw();\n    }\n    draw() {\n        const { ctx, bufferCanvas, canvas, bufferCtx } = this;\n        redrawBoundBackGround(this.canvas);\n        ctx.drawImage(this.backgroundLayer.getLayerCanvas(), 0, 0);\n        ctx.drawImage(bufferCanvas, 0, 0);\n    }\n    zoom(e) {\n        const { canvas, ctx, bufferCanvas } = this;\n        const currentTransformedCursor = getTransformedPoint(e, canvas, this.ctx);\n        const zoom = e.deltaY < 0 ? 1.1 : 0.9;\n        const maxZoom = 15; // maximum zoom level\n        const minZoom = 0.1; // minimum zoom level\n        const currentZoom = getCurrentZoom(ctx); // helper function to get current zoom level\n        // Calculate the new zoom level, making sure it stays within the maximum and minimum bounds\n        const newZoom = Math.min(Math.max(currentZoom * zoom, minZoom), maxZoom);\n        // Calculate the difference in zoom level between the new and old zoom levels\n        const zoomDiff = newZoom / currentZoom;\n        if (newZoom < 0.11) {\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.scale(newZoom, newZoom);\n            ctx.translate(-canvas.width / 2, -canvas.height / 2);\n            ctx.transform(1, 0, 0, 1, (canvas.width - bufferCanvas.width) / 2, (canvas.height - bufferCanvas.height) / 2);\n        }\n        else {\n            ctx.translate(currentTransformedCursor.x, currentTransformedCursor.y);\n            ctx.scale(zoomDiff, zoomDiff);\n            ctx.translate(-currentTransformedCursor.x, -currentTransformedCursor.y);\n        }\n        this.backgroundLayer.zoom(e, newZoom);\n        this.draw();\n    }\n    cleanCanvas() {\n        const { canvas, ctx, bufferCanvas, bufferCtx } = this;\n        // debugger;\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('mousedown', this.mouseDown);\n        // canvas.addEventListener('mousemove', this.mouseMove);\n        // canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('mousedown', this.mouseDown(this));\n        // canvas.removeEventListener('mousemove', this.mouseMove(this));\n        // canvas.removeEventListener('mouseup', this.mouseUp(this));\n        canvas.removeEventListener('touchstart', this.mouseDown(this));\n        canvas.removeEventListener('touchmove', this.mouseMove(this));\n        canvas.removeEventListener('touchend', this.mouseUp(this));\n        canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default Views;\n","import Point from '../Point';\nimport Layer from './Layer';\nclass BackgroundLayer extends Layer {\n    constructor(canvas) {\n        super(canvas);\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n        this.backgroundCanvas = document.createElement('canvas');\n        this.backgroundCanvas.width = canvas.width;\n        this.backgroundCanvas.height = canvas.height;\n        this.backgroundCtx = this.backgroundCanvas.getContext('2d');\n        this.registerEvent(this.backgroundCanvas);\n        this.rectSize = 20;\n        this.draw();\n    }\n    draw() {\n        const { backgroundCanvas, backgroundCtx, rectSize } = this;\n        const numRows = Math.floor(backgroundCanvas.height / rectSize);\n        const numCols = Math.floor(backgroundCanvas.width / rectSize);\n        const rectWidth = backgroundCanvas.width / numCols;\n        const rectHeight = backgroundCanvas.height / numRows;\n        // loop through the rows\n        for (let i = 0; i < numRows; i++) {\n            // loop through the columns\n            for (let j = 0; j < numCols; j++) {\n                // calculate the x and y coordinates of the rectangle\n                const x = j * rectWidth;\n                const y = i * rectHeight;\n                // fill the rectangle with grey or white depending on the row and column\n                if ((i + j) % 2 === 0) {\n                    backgroundCtx.fillStyle = '#dddddd';\n                }\n                else {\n                    backgroundCtx.fillStyle = '#ffffff';\n                }\n                backgroundCtx.fillRect(x, y, rectWidth, rectHeight);\n            }\n        }\n    }\n    zoom(e, zoomLevel) {\n        this.rectSize = Math.min(40 / zoomLevel, 20);\n        this.draw();\n    }\n    getLayerCanvas() {\n        return this.backgroundCanvas;\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default BackgroundLayer;\n","import Point from '../Point';\nimport Layer from './Layer';\nclass FileLayer extends Layer {\n    constructor(canvas) {\n        super(canvas);\n        this.image = new Image();\n        this.ctx = canvas.getContext('2d');\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n    }\n    async loadFile(file) {\n        const { ctx, canvas, position, image } = this;\n    }\n    redraw() { }\n}\nexport default FileLayer;\n","import Point from '../Point';\nclass Layer {\n    constructor(canvas) {\n        this.isDrawStart = false;\n        this.position = { x: 0, y: 0 };\n        this.ctx = canvas.getContext('2d');\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n    }\n    draw() { }\n}\nexport default Layer;\n","class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport default Point;\n","class BaseTool {\n    constructor(views) {\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n        this.views = views;\n        this.canvas = views.canvas;\n        this.bufferCanvas = views.bufferCanvas;\n        this.bufferCtx = views.bufferCtx;\n        this.ctx = views.ctx;\n    }\n    draw(e) {\n        const { views } = this;\n        views.draw();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default BaseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass BrushTool extends BaseTool {\n    constructor(views) {\n        super(views);\n        this.isDrawStart = false;\n        this.setColor = (color) => {\n            this.color = color;\n        };\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            this.isDrawStart = false;\n            this.draw(e);\n        };\n        this.lastPoint = new Point(0, 0);\n        this.setColor('black');\n        this.size = 5;\n        this.registerEvent(views.canvas);\n    }\n    draw(e) {\n        const { bufferCtx, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.strokeStyle = this.color;\n        bufferCtx.lineWidth = this.size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default BrushTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass EraseTool extends BaseTool {\n    constructor(views) {\n        super(views);\n        this.isDrawStart = false;\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { bufferCtx } = this;\n            this.draw(e);\n            this.isDrawStart = false;\n            bufferCtx.globalCompositeOperation = 'source-over';\n        };\n        this.lastPoint = new Point(0, 0);\n        this.size = 5;\n        this.registerEvent(views.canvas);\n    }\n    draw(e) {\n        const { bufferCtx, size, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.globalCompositeOperation = 'destination-out';\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.lineWidth = size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default EraseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass PanTool extends BaseTool {\n    constructor(views) {\n        super(views);\n        this.isPanStart = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isPanStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx } = this;\n            e.preventDefault();\n            if (!this.isPanStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            this.isPanStart = false;\n        };\n        this.lastPoint = new Point(0, 0);\n        this.registerEvent(views.canvas);\n    }\n    draw(e) {\n        const { ctx, canvas } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        ctx.translate(currentTransformedCursor.x - this.lastPoint.x, currentTransformedCursor.y - this.lastPoint.y);\n        super.draw(e);\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default PanTool;\n","import EraseTool from './Erase';\nimport BrushTool from './Brush';\nimport PanTool from './Pan';\nexport const Tools = {\n    BrushTool,\n    EraseTool,\n    PanTool,\n};\nexport default function dynamicClass(name) {\n    return Tools[name];\n}\n"],"names":[],"sourceRoot":""}