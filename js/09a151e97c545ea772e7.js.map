{"version":3,"file":"09a151e97c545ea772e7.js","mappings":";;;;;;;;;;;;;;;;AAA0B;AACwD;AAClF;AACA,YAAY,0DAAmB,UAAU,mGAAmG;AAC5I,QAAQ,0DAAmB,CAAC,wFAAiB,IAAI,sFAAsF;AACvI;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;ACNpB;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;ACfO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACrB8C;AACZ;AAC2B;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,2DAAc;AACtC;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,uBAAuB,+CAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAmB;AACtC;AACA;AACA,mBAAmB,iFAAsB;AACzC;AACA;AACA,mBAAmB,+EAAoB;AACvC;AACA;AACA,mBAAmB,kFAAuB;AAC1C;AACA;AACA,mBAAmB,0EAAe;AAClC;AACA;AACA,mBAAmB,2EAAgB;AACnC;AACA;AACA,mBAAmB,4EAAiB;AACpC;AACA;AACA,mBAAmB,6EAAkB;AACrC;AACA;AACA;AACA,eAAe,2EAAgB;AAC/B;AACA;;;;;;;;;;;;;;;;;;;AC/GO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;ACLA,sBAAsB;AACtB;AACA;AACA","sources":["webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts","webpack://leetcodecrack/./src/utils/canvas/mainCanvas.ts","webpack://leetcodecrack/./src/utils/canvas/rasterCanvas.ts","webpack://leetcodecrack/./src/utils/canvas/rect.ts","webpack://leetcodecrack/./src/utils/image.ts","webpack://leetcodecrack/./src/utils/canvas/constants.js"],"sourcesContent":["import React from 'react';\nimport CanvasImageEditor from '~/canvas/components/ImageEditor/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: `relative m-auto flex h-full max-h-screen w-full flex-col items-center justify-center` },\n        React.createElement(CanvasImageEditor, { className: \"relative  flex h-full w-full  flex-row border border-solid border-white\" })));\n};\nexport default ImageEditor;\n","export function getTransformedPaintPoint(e, canvas, ctx, scale = 1) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    console.log(ctx.getTransform());\n    const originalPoint = new DOMPoint(offsetX - rect.left, offsetY, rect.top);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPoints(e, canvas, ctx) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const originalPoint = new DOMPoint(pageX - rect.left, pageY - rect.top);\n    const point = ctx.getTransform().invertSelf().transformPoint(originalPoint);\n    const x = point.x;\n    const y = point.y;\n    return { x: x, y: y };\n}\n","export function getCurrentZoom(ctx) {\n    // Extract the current transformation matrix from the context\n    const matrix = ctx.getTransform();\n    // Calculate the current zoom level as the square root of the determinant of the transformation matrix\n    // (see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/determinant)\n    return Math.sqrt(Math.abs(matrix.a * matrix.d - matrix.b * matrix.c));\n}\nexport function redrawBoundBackGround(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nexport function updateCanvasSize(mianCanvas, rasterCanvas, width, height) {\n    mianCanvas.width = width;\n    mianCanvas.height = height;\n    rasterCanvas.width = width;\n    rasterCanvas.height = height;\n}\n","import { getCurrentZoom } from './mainCanvas';\nimport { IsInRect } from './rect';\nimport { CursorPoint } from '~/canvas/ImageEditor/Tool/Crop';\nexport function redrawRasterBoundBackGround(rasterCanvas) {\n    const ctx = rasterCanvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, rasterCanvas.width, rasterCanvas.height);\n    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';\n    ctx.fillRect(0, 0, rasterCanvas.width, rasterCanvas.height);\n    ctx.restore();\n}\nexport function drawCropFiled(ctx, bufferCanvas, rasterCtx, rasterCanvas, isDrawOdd, focusRect) {\n    const lineWidth = 2;\n    redrawRasterBoundBackGround(rasterCanvas);\n    const transform = ctx.getTransform();\n    const currentZoom = getCurrentZoom(ctx);\n    rasterCtx.clearRect(focusRect.left, focusRect.top, focusRect.getWidth(), focusRect.getHeight());\n    rasterCtx.strokeStyle = 'white';\n    rasterCtx.strokeRect(focusRect.left - lineWidth, focusRect.top - lineWidth, focusRect.getWidth() + lineWidth * 2, focusRect.getHeight() + lineWidth * 2);\n    // Draw vertical lines\n    for (let i = 0; i < 4; i++) {\n        if ([0, 3].includes(i) || !isDrawOdd)\n            continue;\n        rasterCtx.beginPath();\n        rasterCtx.strokeStyle = 'white';\n        rasterCtx.lineWidth = lineWidth;\n        rasterCtx.moveTo(focusRect.left + (i * focusRect.getWidth()) / 3, focusRect.top);\n        rasterCtx.lineTo(focusRect.left + (i * focusRect.getWidth()) / 3, focusRect.top + focusRect.getHeight());\n        rasterCtx.stroke();\n        rasterCtx.closePath();\n    }\n    // Draw horizontal lines\n    for (let i = 0; i < 4; i++) {\n        if ([0, 3].includes(i) || !isDrawOdd)\n            continue;\n        rasterCtx.beginPath();\n        rasterCtx.strokeStyle = 'white';\n        rasterCtx.lineWidth = lineWidth;\n        rasterCtx.moveTo(focusRect.left, focusRect.top + (i * focusRect.getHeight()) / 3);\n        rasterCtx.lineTo(focusRect.left + focusRect.getWidth(), focusRect.top + (i * focusRect.getHeight()) / 3);\n        rasterCtx.stroke();\n        rasterCtx.closePath();\n    }\n}\nexport function cropCursorChange(canvas, point, originalRect) {\n    canvas.style.cursor = 'default';\n    const isOutside = !IsInRect(point.x, point.y, originalRect.left, originalRect.top, originalRect.right, originalRect.bottom);\n    if (isOutside) {\n        const isleft = point.x < originalRect.left;\n        const isTop = point.y < originalRect.top;\n        const isRight = point.x > originalRect.right;\n        const isBottom = point.y > originalRect.bottom;\n        if (isTop || isBottom) {\n            canvas.style.cursor = 'ns-resize';\n        }\n        if (isleft || isRight) {\n            canvas.style.cursor = 'ew-resize';\n        }\n        if (isleft && isTop) {\n            canvas.style.cursor = 'nw-resize';\n        }\n        if (isleft && isBottom) {\n            canvas.style.cursor = 'sw-resize';\n        }\n        if (isRight && isTop) {\n            canvas.style.cursor = 'ne-resize';\n        }\n        if (isRight && isBottom) {\n            canvas.style.cursor = 'se-resize';\n        }\n    }\n    else {\n        canvas.style.cursor = 'move';\n    }\n}\nexport function getCursorPoint(point, focusRect) {\n    const isOutside = !IsInRect(point.x, point.y, focusRect.left, focusRect.top, focusRect.right, focusRect.bottom);\n    if (isOutside) {\n        const isleft = point.x < focusRect.left;\n        const isTop = point.y < focusRect.top;\n        const isRight = point.x > focusRect.right;\n        const isBottom = point.y > focusRect.bottom;\n        if (isleft && isTop) {\n            return CursorPoint.topLeft;\n        }\n        if (isleft && isBottom) {\n            return CursorPoint.bottomLeft;\n        }\n        if (isRight && isTop) {\n            return CursorPoint.topRight;\n        }\n        if (isRight && isBottom) {\n            return CursorPoint.bottomRight;\n        }\n        if (isTop) {\n            return CursorPoint.top;\n        }\n        if (isleft) {\n            return CursorPoint.left;\n        }\n        if (isRight) {\n            return CursorPoint.right;\n        }\n        if (isBottom) {\n            return CursorPoint.bottom;\n        }\n    }\n    else {\n        return CursorPoint.move;\n    }\n}\n","export function IsInRect(x, y, left, top, right, bottom) {\n    return x >= left && x <= right && y >= top && y <= bottom;\n}\nexport function IsOutRect(x, y, left, top, right, bottom) {\n    return x < left || x > right || y < top || y > bottom;\n}\nexport function IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n    return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n}\nexport function getNewSize(canvas, image) {\n    const widthRatio = canvas.width / image.width;\n    const heightRatio = canvas.height / image.height;\n    // Use the smaller ratio to ensure that the image fits inside the canvas\n    const scale = Math.min(widthRatio, heightRatio);\n    // Calculate the new width and height of the image\n    const newWidth = image.width * scale;\n    const newHeight = image.height * scale;\n    return { newWidth, newHeight };\n}\n","export function onload2promise(obj) {\n    return new Promise((resolve, reject) => {\n        obj.onload = () => resolve(obj);\n        obj.onerror = reject;\n    });\n}\n","const LAYOUT_SIZE = { MENU_WIDTH: '2.5rem', PANEL_WIDTH: '10rem' };\nmodule.exports = {\n    LAYOUT_SIZE,\n}"],"names":[],"sourceRoot":""}