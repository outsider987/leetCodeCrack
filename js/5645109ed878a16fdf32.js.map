{"version":3,"file":"5645109ed878a16fdf32.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AC3CyC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;ACpEwC;AACpC;AACM;AACwB;AACoC;AACpE;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC,uBAAuB,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE,oBAAoB,mBAAmB;AACvC,qCAAqC,0EAAc,GAAG,wBAAwB;AAC9E;AACA;AACA;AACA,oBAAoB,qDAAqD;AACzE,oBAAoB,mBAAmB;AACvC,4BAA4B;AAC5B,gCAAgC,wEAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4EAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,6BAA6B,8CAAK;AAClC;AACA;AACA,4BAA4B,wEAAc;AAC1C,gCAAgC,6CAAI;AACpC,6BAA6B,6CAAI;AACjC;AACA;AACA,gBAAgB,iFAAiF;AACjG,QAAQ,yEAAa;AACrB;AACA,4BAA4B,wEAAc;AAC1C;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,4BAA4B,wEAAc;AAC1C;AACA;AACA;AACA;AACA,gBAAgB,kDAAkD;AAClE;AACA,4BAA4B,wEAAc;AAC1C;AACA,gBAAgB,2BAA2B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8EAA8E;AAC9F,4BAA4B,wEAAc,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AC9MyC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;ACnEwC;AACpC;AACM;AACnC,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA,gBAAgB,cAAc;AAC9B,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;ACtDS;AACA;AACJ;AACE;AACvB;AACP,aAAa;AACb,aAAa;AACb,WAAW;AACX,YAAY;AACZ;AACe;AACf;AACA","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/BaselTool.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Brush.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Crop.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Erase.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Pan.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/index.ts"],"sourcesContent":["class BaseTool {\n    constructor(views, stateController, rasterViews) {\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n        this.views = views;\n        this.canvas = views.canvas;\n        this.bufferCanvas = views.bufferCanvas;\n        this.bufferCtx = views.bufferCtx;\n        this.ctx = views.ctx;\n        this.stateController = stateController;\n        this.rasterCanvas = rasterViews.rasterCanvas;\n        this.rasterCtx = rasterViews.rasterCtx;\n        this.rasterViews = rasterViews;\n    }\n    draw(e) {\n        const { views } = this;\n        views.draw();\n    }\n    zoom(e) { }\n    doCmd() {\n        const { stateController } = this;\n        stateController.pushUndoStack();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n        canvas.removeEventListener('wheel', this.zoom);\n    }\n}\nexport default BaseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass BrushTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrawStart = false;\n        this.setColor = (color) => {\n            this.color = color;\n        };\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            this.isDrawStart = false;\n            this.draw(e);\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n        this.setColor('black');\n        this.size = 5;\n    }\n    draw(e) {\n        const { bufferCtx, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.strokeStyle = this.color;\n        bufferCtx.lineWidth = this.size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default BrushTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nimport { getCurrentZoom } from '~/utils/canvas/mainCanvas';\nimport { cropCursorChange, drawCropFiled, getCursorPoint, } from '~/utils/canvas/rasterCanvas';\nimport Rect from '../Rect';\nexport var CursorPoint;\n(function (CursorPoint) {\n    CursorPoint[\"left\"] = \"left\";\n    CursorPoint[\"right\"] = \"right\";\n    CursorPoint[\"top\"] = \"top\";\n    CursorPoint[\"bottom\"] = \"bottom\";\n    CursorPoint[\"topLeft\"] = \"topLeft\";\n    CursorPoint[\"topRight\"] = \"topRight\";\n    CursorPoint[\"bottomLeft\"] = \"bottomLeft\";\n    CursorPoint[\"bottomRight\"] = \"bottomRight\";\n    CursorPoint[\"move\"] = \"move\";\n})(CursorPoint || (CursorPoint = {}));\nclass CropTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrag = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrag = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n            this.currentCusorPoint = getCursorPoint({ x: offsetX, y: offsetY }, this.focusRect);\n            this.lastPoint.setPoint(offsetX, offsetY);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx, bufferCanvas, originalRect, focusRect } = this;\n            const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n            const point = { x: offsetX, y: offsetY };\n            const currentZoom = getCurrentZoom(ctx);\n            const clientWidth = bufferCanvas.width * currentZoom;\n            const clientHeight = bufferCanvas.height * currentZoom;\n            const MIN_DISTANCE = Math.min(clientWidth, clientHeight) > 50 ? 50 : Math.min(clientWidth, clientHeight);\n            console.log(MIN_DISTANCE);\n            e.preventDefault();\n            if (!this.isDrag) {\n                cropCursorChange(canvas, point, focusRect);\n                return;\n            }\n            if (this.currentCusorPoint === CursorPoint.move) {\n                let dx = offsetX - this.lastPoint.x;\n                let dy = offsetY - this.lastPoint.y;\n                // calculate new position\n                const newLeft = focusRect.left + dx;\n                const newRight = focusRect.right + dx;\n                const newTop = focusRect.top + dy;\n                const newBottom = focusRect.bottom + dy;\n                // check whether new position is within bounds sides\n                if (newLeft < originalRect.left) {\n                    dx = originalRect.left - focusRect.left;\n                }\n                if (newTop < originalRect.top) {\n                    dy = originalRect.top - focusRect.top;\n                }\n                if (newRight > originalRect.right) {\n                    dx = originalRect.right - focusRect.right;\n                }\n                if (newBottom > originalRect.bottom) {\n                    dy = originalRect.bottom - focusRect.bottom;\n                }\n                // update focusRect with modified dx and dy\n                this.focusRect.left += dx;\n                this.focusRect.right += dx;\n                this.focusRect.top += dy;\n                this.focusRect.bottom += dy;\n                this.lastPoint.setPoint(offsetX, offsetY);\n            }\n            if (this.currentCusorPoint === CursorPoint.left) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), focusRect.right - MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.top) {\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), focusRect.bottom - MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.right) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), focusRect.left + MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottom) {\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), focusRect.top + MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.topLeft) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), focusRect.right - MIN_DISTANCE);\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), focusRect.bottom - MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.topRight) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), focusRect.left + MIN_DISTANCE);\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), focusRect.bottom - MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottomLeft) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), focusRect.right - MIN_DISTANCE);\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), focusRect.top + MIN_DISTANCE);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottomRight) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), focusRect.left + MIN_DISTANCE);\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), focusRect.top + MIN_DISTANCE);\n            }\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            this.isDrag = false;\n            this.draw(e);\n        };\n        const { ctx, bufferCanvas } = this;\n        this.lastPoint = new Point(0, 0);\n        this.zoomBindObject = this.zoom.bind(this, views.canvas);\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect = new Rect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.focusRect = new Rect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    draw(e) {\n        const { ctx, rasterCanvas, canvas, rasterCtx, bufferCanvas, isDrag: isStart, focusRect } = this;\n        drawCropFiled(ctx, bufferCanvas, rasterCtx, rasterCanvas, isStart, focusRect);\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    resetRect() {\n        const { ctx, bufferCanvas } = this;\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.focusRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    onConfirm() {\n        const { ctx, bufferCanvas, focusRect, bufferCtx, canvas } = this;\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        const { left, right, top, bottom } = focusRect;\n        const dLeft = left - this.originalRect.left;\n        const dRight = right - this.originalRect.right;\n        const dTop = top - this.originalRect.top;\n        const dBottom = bottom - this.originalRect.bottom;\n        const widthRatio = bufferCanvas.width / this.originalRect.getWidth();\n        const heightRatio = bufferCanvas.height / this.originalRect.getHeight();\n        const imageData = bufferCtx.getImageData(dLeft * widthRatio, dTop * heightRatio, this.focusRect.getWidth() * widthRatio, this.focusRect.getHeight() * heightRatio);\n        this.bufferCanvas.width = imageData.width;\n        this.bufferCanvas.height = imageData.height;\n        bufferCtx.putImageData(imageData, 0, 0);\n        // refine the focusRect and originalRect\n        super.draw();\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.focusRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.draw();\n        this.stateController.pushUndoStack();\n    }\n    zoom(e) {\n        const { ctx, rasterCanvas, canvas, rasterCtx, bufferCanvas, originalRect, focusRect } = this;\n        const currentZoom = getCurrentZoom(ctx); // helper function to get current zoom level\n        const transform = ctx.getTransform();\n        const currentOriginalRect = this.originalRect;\n        const currentFocusRect = this.focusRect;\n        const currentdLeft = currentOriginalRect.left - currentFocusRect.left;\n        const currentdRight = currentOriginalRect.right - currentFocusRect.right;\n        const currentdTop = currentOriginalRect.top - currentFocusRect.top;\n        const currentdBottom = currentOriginalRect.bottom - currentFocusRect.bottom;\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        const widthRatio = currentOriginalRect.getWidth() / currentFocusRect.getWidth();\n        const heightRatio = currentOriginalRect.getHeight() / currentFocusRect.getHeight();\n        this.focusRect.setRect(this.originalRect.left + widthRatio * currentdLeft, this.originalRect.top + heightRatio * currentdTop, this.originalRect.right + widthRatio * currentdRight, this.originalRect.bottom + heightRatio * currentdBottom);\n        const currentOriginalRect2 = this.originalRect;\n        const currentFocusRect2 = this.focusRect;\n        const currentdLeft2 = currentOriginalRect2.left - currentFocusRect2.left;\n        const currentdRight2 = currentOriginalRect2.right - currentFocusRect2.right;\n        const currentdTop2 = currentOriginalRect2.top - currentFocusRect2.top;\n        const currentdBottom2 = currentOriginalRect2.bottom - currentFocusRect2.bottom;\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        const widthRatio2 = currentOriginalRect.getWidth() / currentFocusRect.getWidth();\n        const heightRatio2 = currentOriginalRect.getHeight() / currentFocusRect.getHeight();\n        this.focusRect.setRect(this.originalRect.left + widthRatio2 * currentdLeft2, this.originalRect.top + heightRatio2 * currentdTop2, this.originalRect.right + widthRatio2 * currentdRight2, this.originalRect.bottom + heightRatio2 * currentdBottom2);\n        this.draw(e);\n    }\n    cleanCanvas() {\n        this.rasterCtx.clearRect(0, 0, this.rasterCanvas.width, this.rasterCanvas.height);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoomBindObject);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n        canvas.removeEventListener('wheel', this.zoomBindObject);\n        this.cleanCanvas();\n        this.canvas.style.cursor = 'default';\n    }\n}\nexport default CropTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass EraseTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrawStart = false;\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { bufferCtx } = this;\n            this.draw(e);\n            this.isDrawStart = false;\n            bufferCtx.globalCompositeOperation = 'source-over';\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n        this.size = 5;\n    }\n    draw(e) {\n        const { bufferCtx, size, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.globalCompositeOperation = 'destination-out';\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.lineWidth = size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default EraseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass PanTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isPanStart = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isPanStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx } = this;\n            e.preventDefault();\n            if (!this.isPanStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            this.isPanStart = false;\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n    }\n    draw(e) {\n        const { ctx, canvas } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        ctx.translate(currentTransformedCursor.x - this.lastPoint.x, currentTransformedCursor.y - this.lastPoint.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default PanTool;\n","import EraseTool from './Erase';\nimport BrushTool from './Brush';\nimport PanTool from './Pan';\nimport CropTool from './Crop';\nexport const Tools = {\n    BrushTool,\n    EraseTool,\n    PanTool,\n    CropTool,\n};\nexport default function dynamicClass(name) {\n    return Tools[name];\n}\n"],"names":[],"sourceRoot":""}