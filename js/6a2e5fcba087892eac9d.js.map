{"version":3,"file":"6a2e5fcba087892eac9d.js","mappings":";;;;;;;;;;;;;;;;;;AAA2D;AACJ;AAC7B;AAC6B;AACvD;AACA,sBAAsB,6CAAM;AAC5B,4BAA4B,+CAAQ;AACpC,qBAAqB,6CAAM,KAAK,yEAAK;AACrC,uBAAuB,6CAAM;AAC7B;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,oEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,CAAC,uDAAc;AAC9C,QAAQ,0DAAmB,UAAU,cAAc,iBAAiB,aAAa;AACjF,YAAY,0DAAmB,UAAU,yBAAyB;AAClE,gBAAgB,0DAAmB,CAAC,6CAAI,IAAI,kDAAkD;AAC9F,YAAY,0DAAmB,UAAU,sHAAsH;AAC/J,kCAAkC,0DAAmB,UAAU,gEAAgE;AAC/H,oBAAoB,0DAAmB,UAAU,0BAA0B;AAC3E,oBAAoB,0DAAmB,YAAY,sHAAsH;AACzK,uCAAuC,0DAAmB,aAAa,gGAAgG;AACvK;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;;;;;ACtD0B;AACwB;AAC9B;AACrD,gBAAgB,yBAAyB;AACzC,oBAAoB,6CAAM;AAC1B,4BAA4B,+CAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA,8BAA8B,oEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,0DAAmB,CAAC,2DAAK,IAAI,iBAAiB;AACtD,QAAQ,0DAAmB,CAAC,2DAAO,IAAI,gBAAgB;AACvD,QAAQ,0DAAmB,CAAC,2DAAa,IAAI,kBAAkB;AAC/D,QAAQ,0DAAmB,CAAC,2DAAa,IAAI,uBAAuB;AACpE;AACA,YAAY,0DAAmB,UAAU,yFAAyF,8BAA8B,0DAAmB,UAAU,0CAA0C;AACvO;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;ACpCM;AACwD;AAClF;AACA,YAAY,0DAAmB,UAAU,+EAA+E;AACxH,QAAQ,0DAAmB,CAAC,wFAAiB,IAAI,2GAA2G;AAC5J;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACNpB;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,+BAA+B,EAAE;AACjC,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;AC9CO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://leetcodecrack/./src/canvas/components/ImageEditor/CanvasImageEditor.tsx","webpack://leetcodecrack/./src/canvas/components/ImageEditor/Menu.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/canvas.ts","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts","webpack://leetcodecrack/./src/utils/canvas/rect.ts","webpack://leetcodecrack/./src/utils/image.ts"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\nimport Views from '~/canvas/ImageEditor/Canvas/Canvas';\nimport Menu from './Menu';\nimport { getCurrentZoom } from '~/utils/canvas/canvas';\nconst CanvasImageEditor = (props) => {\n    const canvasRef = useRef(null);\n    const [file, setFile] = useState(null);\n    const ViewsRef = useRef(new Views());\n    const ContentRef = useRef();\n    const onClickFile = (e) => {\n        setFile(e.target.files[0]);\n    };\n    useEffect(() => {\n        if (!canvasRef.current || !ContentRef.current || file === null)\n            return;\n        ViewsRef.current.initializeCanvas(canvasRef.current);\n        canvasRef.current.width = ContentRef.current.offsetWidth;\n        canvasRef.current.height = ContentRef.current.offsetHeight;\n        ViewsRef.current.loadFile(file);\n        const observer = new ResizeObserver((entries) => {\n            entries.forEach((entry) => {\n                updateDimensions();\n            });\n        });\n        observer.observe(canvasRef.current);\n        return () => {\n            observer.unobserve(canvasRef.current);\n            ViewsRef.current.cleanCanvas();\n        };\n    }, [file]);\n    const updateDimensions = () => {\n        if (canvasRef.current && file !== null) {\n            // adjust the canvas size to match the size of its container\n            const zoomLevel = getCurrentZoom(ViewsRef.current.ctx);\n            const x = ViewsRef.current.ctx.getTransform().e + ContentRef.current.offsetWidth - canvasRef.current.width;\n            const y = ViewsRef.current.ctx.getTransform().f + ContentRef.current.offsetHeight - canvasRef.current.height;\n            // reset the transform matrix as it is cumulative\n            canvasRef.current.width = ContentRef.current.offsetWidth;\n            canvasRef.current.height = ContentRef.current.offsetHeight;\n            ViewsRef.current.ctx.translate(x, y);\n            ViewsRef.current.ctx.scale(zoomLevel, zoomLevel);\n            ViewsRef.current.draw();\n        }\n    };\n    return (React.createElement(React.Fragment, null,\n        React.createElement(\"div\", { className: `${props.className} h-[100vh] ` },\n            React.createElement(\"div\", { className: \"flex w-10 \" },\n                React.createElement(Menu, { ViewsRef: ViewsRef, setFile: setFile, file: file })),\n            React.createElement(\"div\", { ref: ContentRef, className: `relative flex w-full max-w-[calc(100%-2.5rem)]  border  border-solid border-yellow-400` },\n                file === null && (React.createElement(\"div\", { className: \"absolute inset-0 flex items-center justify-center\" },\n                    React.createElement(\"div\", { className: \" text-white\" }, \"please click or drag file\"),\n                    React.createElement(\"input\", { onChange: onClickFile, className: `absolute inset-0 z-10 cursor-pointer opacity-0 `, type: \"file\", accept: \"image/*\" }))),\n                ContentRef.current && (React.createElement(\"canvas\", { ref: canvasRef, width: ContentRef.current.offsetWidth, height: ContentRef.current.offsetHeight }))))));\n};\nexport default CanvasImageEditor;\n","import React, { useRef, useEffect, useState } from 'react';\nimport { Brush, PanTool, DeleteForever, AutoFixNormal } from '@mui/icons-material';\nimport dynamicClass from '~/canvas/ImageEditor/Tool';\nconst Menu = ({ ViewsRef, setFile, file }) => {\n    const menuRef = useRef(null);\n    const [mode, setMode] = useState(null);\n    const onDeleteFile = (e) => {\n        setFile(null);\n    };\n    const onDraw = () => {\n        setMode('PaintTool');\n    };\n    const onErase = () => {\n        setMode('EraseTool');\n    };\n    const onPan = () => {\n        setMode('PanTool');\n    };\n    useEffect(() => {\n        if (ViewsRef.current.canvas && file !== null) {\n            // const ctx = paintCanvasRef.current.getContext('2d');\n            const ToolClass = dynamicClass(mode);\n            let tool = new ToolClass(ViewsRef.current);\n            return () => {\n                tool.unRegisterEvent(ViewsRef.current.canvas);\n            };\n        }\n    }, [mode]);\n    const tools = [\n        React.createElement(Brush, { onClick: onDraw }),\n        React.createElement(PanTool, { onClick: onPan }),\n        React.createElement(AutoFixNormal, { onClick: onErase }),\n        React.createElement(DeleteForever, { onClick: onDeleteFile }),\n    ];\n    return (React.createElement(\"div\", { className: \" inset-y-0 left-0 flex w-[2vw] flex-col items-center space-y-3  text-white\" }, tools.map((tool, index) => (React.createElement(\"div\", { className: \" cursor-pointer\", key: index }, tool)))));\n};\nexport default Menu;\n","import React from 'react';\nimport CanvasImageEditor from '~/canvas/components/ImageEditor/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: \"relative m-auto flex w-full flex-col items-center justify-center\" },\n        React.createElement(CanvasImageEditor, { className: \"relative  flex h-full w-full max-w-[100vw-(240px)] flex-row border border-solid border-white\" })));\n};\nexport default ImageEditor;\n","export function getCurrentZoom(ctx) {\n    // Extract the current transformation matrix from the context\n    const matrix = ctx.getTransform();\n    // Calculate the current zoom level as the square root of the determinant of the transformation matrix\n    // (see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/determinant)\n    return Math.sqrt(Math.abs(matrix.a * matrix.d - matrix.b * matrix.c));\n}\nexport function redrawBoundBackGround(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\n","export function getClientOffset(e, canvas, scale = 1, offsetPoint) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    // var offsetX=canvasOffset.left;\n    // var offsetY=canvasOffset.top;\n    const rect = canvas.getBoundingClientRect();\n    // console.log(rect);\n    console.log(`pageX: ${pageX}`);\n    console.log(`offsetLeft: ${e}`);\n    console.log(`scale:${scale}`);\n    // const x = pageX - rect.left;\n    // const y = pageY - rect.top;\n    const x = (pageX - rect.left - canvas.width / 2) / scale + canvas.width / 2;\n    const y = (pageY - rect.top - canvas.height / 2) / scale + canvas.height / 2;\n    console.log(`final:${x}`);\n    return {\n        x,\n        y,\n    };\n}\n// export function getTransformedPoint(e, ctx: CanvasRenderingContext2D) {\n//   const { offsetx: pageX, offsetY: pageY } = e.touches ? e.touches[0] : e;\n//   const originalPoint = new DOMPoint(e.offsetx, e.offsetY);\n//   return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n// }\nexport function getTransformedPoint(e, canvas, ctx) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const originalPoint = new DOMPoint(offsetX, offsetY);\n    // const t = ctx.getTransform();\n    // console.log(t);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPaintPoint(e, canvas, ctx, scale = 1) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    console.log(ctx.getTransform());\n    const originalPoint = new DOMPoint(offsetX - rect.left, offsetY, rect.top);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPoints(e, canvas, ctx) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const originalPoint = new DOMPoint(pageX - rect.left, pageY - rect.top);\n    const point = ctx.getTransform().invertSelf().transformPoint(originalPoint);\n    const x = point.x;\n    const y = point.y;\n    return { x: x, y: y };\n}\n","export function IsInRect(x, y, left, top, right, bottom) {\n    return x >= left && x <= right && y >= top && y <= bottom;\n}\nexport function IsOutRect(x, y, left, top, right, bottom) {\n    return x < left || x > right || y < top || y > bottom;\n}\nexport function IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n    return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n}\nexport function getNewSize(canvas, image) {\n    const widthRatio = canvas.width / image.width;\n    const heightRatio = canvas.height / image.height;\n    // Use the smaller ratio to ensure that the image fits inside the canvas\n    const scale = Math.min(widthRatio, heightRatio);\n    // Calculate the new width and height of the image\n    const newWidth = image.width * scale;\n    const newHeight = image.height * scale;\n    return { newWidth, newHeight };\n}\n","export function onload2promise(obj) {\n    return new Promise((resolve, reject) => {\n        obj.onload = () => resolve(obj);\n        obj.onerror = reject;\n    });\n}\n"],"names":[],"sourceRoot":""}