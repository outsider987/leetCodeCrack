{"version":3,"file":"ce6e39ce6d4a84f702ae.js","mappings":";;;;;;;;;;;;;;;;;AAAgE;AACrB;AACY;AACuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6EAAmB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C,0BAA0B,wDAAS;AACnC;AACA;AACA,mCAAmC,8DAAe;AAClD;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,QAAQ,2EAAqB;AAC7B;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,yCAAyC,6EAAmB;AAC5D;AACA,4BAA4B;AAC5B,8BAA8B;AAC9B,4BAA4B,oEAAc,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uCAAuC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;AChGQ;AACD;AAC5B,8BAA8B,8CAAK;AACnC;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4CAA4C;AAC5D;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;;;ACrDF;AACD;AAC5B,wBAAwB,8CAAK;AAC7B;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;AChC6B;AAC7B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;ACXrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;ACV4C;AACpC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD,6CAA6C,8EAAoB;AACjE,8BAA8B,8DAA8D;AAC5F;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,6CAA6C,8EAAoB;AACjE,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;ACtEyC;AACrC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;AC9DwC;AACpC;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,6CAA6C,8EAAoB;AACjE,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;ACvES;AACA;AACJ;AACrB;AACP,aAAa;AACb,aAAa;AACb,WAAW;AACX;AACe;AACf;AACA;;;;;;;;;;;;;;;;;;;;;ACV2D;AAC5B;AACsB;AACE;AAC7B;AAC1B;AACA,sBAAsB,6CAAM;AAC5B,4BAA4B,+CAAQ;AACpC,4BAA4B,+CAAQ;AACpC,qBAAqB,6CAAM,KAAK,yEAAK;AACrC,uBAAuB,6CAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA,8BAA8B,oEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAmB,CAAC,uDAAc;AAC9C,QAAQ,0DAAmB,UAAU,wEAAwE;AAC7G,8BAA8B,0DAAmB,UAAU,gEAAgE;AAC3H,gBAAgB,0DAAmB,UAAU,0BAA0B;AACvE,gBAAgB,0DAAmB,YAAY,sHAAsH;AACrK,YAAY,0DAAmB,aAAa,0BAA0B;AACtE,QAAQ,0DAAmB,UAAU,oCAAoC;AACzE,YAAY,0DAAmB,CAAC,+CAAM,IAAI,uBAAuB;AACjE,YAAY,0DAAmB,CAAC,+CAAM,IAAI,iBAAiB;AAC3D,YAAY,0DAAmB,CAAC,+CAAM,IAAI,gBAAgB;AAC1D,YAAY,0DAAmB,CAAC,+CAAM,IAAI,kBAAkB;AAC5D,QAAQ,0DAAmB,CAAC,6CAAI;AAChC;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;ACpEe;AACJ;AAC5C;AACA,4BAA4B,+CAAQ;AACpC,oBAAoB,6CAAM;AAC1B,WAAW,0DAAmB,UAAU,yCAAyC,EAAE,0DAAmB,CAAC,2DAAK;AAC5G;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;;ACPM;AACiD;AAC3E;AACA,YAAY,0DAAmB,UAAU,+EAA+E;AACxH,QAAQ,0DAAmB,CAAC,iFAAiB,IAAI,mEAAmE;AACpH;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACNpB;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACfO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA,0BAA0B,MAAM;AAChC,+BAA+B,EAAE;AACjC,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA,yBAAyB,EAAE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iCAAiC;AAC9C;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Canvas/Canvas.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/BackgroundLayer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/FileLayer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/Layer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Point.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Erase.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Paint.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Pan.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/index.ts","webpack://leetcodecrack/./src/components/ImageEditor/CanvasImageEditor.tsx","webpack://leetcodecrack/./src/components/ImageEditor/Menu.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/canvas.ts","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts"],"sourcesContent":["import { getTransformedPoint } from '~/utils/canvas/coordinate';\nimport FileLayer from '../Layer/FileLayer';\nimport BackgroundLayer from '../Layer/BackgroundLayer';\nimport { getCurrentZoom, redrawBoundBackGround } from '~/utils/canvas/canvas';\nclass Views {\n    constructor() {\n        this.isDrawStart = false;\n        this.zoomLevel = 1;\n        this.lastView = null;\n        this.layerArray = [];\n        this.cameraOffsetX = 0;\n        this.cameraOffsetY = 0;\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => {\n            const transformedCursorPosition = getTransformedPoint(e, this.canvas, this.ctx);\n        };\n        this.mouseUp = (e) => { };\n    }\n    initializeCanvas(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n        this.width = canvas.width;\n        this.height = canvas.height;\n        this.bufferCanvas = document.createElement('canvas');\n        this.bufferCanvas.width = canvas.width;\n        this.bufferCanvas.height = canvas.height;\n        this.bufferCtx = this.bufferCanvas.getContext('2d');\n        this.zoomLevel = 0;\n        this.cameraOffsetX = 0;\n        this.cameraOffsetY = 0;\n        this.registerEvent(this.canvas);\n    }\n    async loadFile(file) {\n        const { bufferCanvas, bufferCtx } = this;\n        const layer = new FileLayer(bufferCanvas);\n        this.layerArray.push(layer);\n        await layer.loadFile(file);\n        this.backgroundLayer = new BackgroundLayer(this.canvas);\n        this.draw();\n    }\n    draw() {\n        const { ctx, bufferCanvas } = this;\n        redrawBoundBackGround(this.canvas);\n        ctx.drawImage(this.backgroundLayer.getLayerCanvas(), 0, 0);\n        ctx.drawImage(bufferCanvas, 0, 0);\n    }\n    zoom(e) {\n        const { canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoint(e, canvas, this.ctx);\n        const zoom = e.deltaY < 0 ? 1.1 : 0.9;\n        const maxZoom = 20; // maximum zoom level\n        const minZoom = 0.01; // minimum zoom level\n        const currentZoom = getCurrentZoom(ctx); // helper function to get current zoom level\n        // Calculate the new zoom level, making sure it stays within the maximum and minimum bounds\n        const newZoom = Math.min(Math.max(currentZoom * zoom, minZoom), maxZoom);\n        // Calculate the difference in zoom level between the new and old zoom levels\n        const zoomDiff = newZoom / currentZoom;\n        if (newZoom < 0.3) {\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n            ctx.translate(canvas.width / 2, canvas.height / 2);\n            ctx.scale(newZoom, newZoom);\n            ctx.translate(-canvas.width / 2, -canvas.height / 2);\n        }\n        else {\n            ctx.translate(currentTransformedCursor.x, currentTransformedCursor.y);\n            ctx.scale(zoomDiff, zoomDiff);\n            ctx.translate(-currentTransformedCursor.x, -currentTransformedCursor.y);\n        }\n        this.backgroundLayer.zoom(e, newZoom);\n        this.draw();\n    }\n    cleanCanvas() {\n        const { canvas, ctx, bufferCanvas, bufferCtx } = this;\n        // debugger;\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('mousedown', this.mouseDown);\n        // canvas.addEventListener('mousemove', this.mouseMove);\n        // canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('mousedown', this.mouseDown(this));\n        // canvas.removeEventListener('mousemove', this.mouseMove(this));\n        // canvas.removeEventListener('mouseup', this.mouseUp(this));\n        canvas.removeEventListener('touchstart', this.mouseDown(this));\n        canvas.removeEventListener('touchmove', this.mouseMove(this));\n        canvas.removeEventListener('touchend', this.mouseUp(this));\n        canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default Views;\n","import Point from '../Point';\nimport Layer from './Layer';\nclass BackgroundLayer extends Layer {\n    constructor(canvas) {\n        super(canvas);\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n        this.backgroundCanvas = document.createElement('canvas');\n        this.backgroundCanvas.width = canvas.width;\n        this.backgroundCanvas.height = canvas.height;\n        this.backgroundCtx = this.backgroundCanvas.getContext('2d');\n        this.registerEvent(this.backgroundCanvas);\n        this.rectSize = 20;\n        this.draw();\n    }\n    draw() {\n        const { backgroundCanvas, backgroundCtx, rectSize } = this;\n        const numRows = Math.floor(backgroundCanvas.height / rectSize);\n        const numCols = Math.floor(backgroundCanvas.width / rectSize);\n        const rectWidth = backgroundCanvas.width / numCols;\n        const rectHeight = backgroundCanvas.height / numRows;\n        // loop through the rows\n        for (let i = 0; i < numRows; i++) {\n            // loop through the columns\n            for (let j = 0; j < numCols; j++) {\n                // calculate the x and y coordinates of the rectangle\n                const x = j * rectWidth;\n                const y = i * rectHeight;\n                // fill the rectangle with grey or white depending on the row and column\n                if ((i + j) % 2 === 0) {\n                    backgroundCtx.fillStyle = '#dddddd';\n                }\n                else {\n                    backgroundCtx.fillStyle = '#ffffff';\n                }\n                backgroundCtx.fillRect(x, y, rectWidth, rectHeight);\n            }\n        }\n    }\n    zoom(e, zoomLevel) {\n        this.rectSize = Math.min(40 / zoomLevel, 20);\n        this.draw();\n    }\n    getLayerCanvas() {\n        return this.backgroundCanvas;\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default BackgroundLayer;\n","import Point from '../Point';\nimport Layer from './Layer';\nclass FileLayer extends Layer {\n    constructor(canvas) {\n        super(canvas);\n        this.image = new Image();\n        this.ctx = canvas.getContext('2d');\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n    }\n    async loadFile(file) {\n        const { ctx, canvas, position, image } = this;\n        image.src = URL.createObjectURL(file);\n        await onload2promise(image);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        let ratio = Math.min(canvas.width / image.width, canvas.height / image.height);\n        let x = (canvas.width - image.width * ratio) / 2;\n        let y = (canvas.height - image.height * ratio) / 2;\n        position.x = x;\n        position.y = y;\n        ctx.drawImage(image, 0, 0, image.width, image.height, x, y, image.width * ratio, image.height * ratio);\n    }\n    redraw() { }\n}\nexport default FileLayer;\nfunction onload2promise(obj) {\n    return new Promise((resolve, reject) => {\n        obj.onload = () => resolve(obj);\n        obj.onerror = reject;\n    });\n}\n","import Point from '../Point';\nclass Layer {\n    constructor(canvas) {\n        this.isDrawStart = false;\n        this.position = { x: 0, y: 0 };\n        this.ctx = canvas.getContext('2d');\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n    }\n    draw() { }\n}\nexport default Layer;\n","class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport default Point;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nclass EraseTool {\n    constructor(views) {\n        this.isDrawStart = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, views, eraserPath } = this;\n            const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n            eraserPath.push({ x: currentTransformedCursor.x, y: currentTransformedCursor.y });\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx, views } = this;\n            e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n            const point = new Point(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.erase(point);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx, views } = this;\n            views.bufferCtx.globalCompositeOperation = 'source-over';\n            views.draw();\n            this.isDrawStart = false;\n        };\n        this.canvas = views.bufferCanvas;\n        this.ctx = views.bufferCtx;\n        this.lastPoint = new Point(0, 0);\n        this.views = views;\n        this.registerEvent(views.canvas);\n        this.eraserPath = [];\n    }\n    erase(point) {\n        const { ctx, views, eraserPath } = this;\n        ctx.beginPath();\n        ctx.globalCompositeOperation = 'destination-out';\n        ctx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.lineWidth = 20;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        ctx.closePath();\n        this.lastPoint.setPoint(point.x, point.y);\n        eraserPath.push({ x: point.x, y: point.y });\n        // const testBuifferCanvas = document.getElementById('buffer') as HTMLCanvasElement;\n        // const ctx2 = testBuifferCanvas.getContext('2d');\n        // ctx2.putImageData(views.bufferCtx.getImageData(0, 0, views.bufferCanvas.width, views.bufferCanvas.height), 0, 0);\n        views.draw();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default EraseTool;\n","import { getTransformedPoints, } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nclass PaintTool {\n    constructor(views) {\n        this.isDrawStart = false;\n        this.setColor = (color) => {\n            this.color = color;\n        };\n        this.mouseDown = (e) => {\n            // e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, views, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            // e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            // e.preventDefault();\n            this.isDrawStart = false;\n            this.views.draw();\n        };\n        this.lastPoint = new Point(0, 0);\n        this.setColor('black');\n        this.views = views;\n        this.registerEvent(views.canvas);\n    }\n    draw(e) {\n        const { canvas, ctx, views } = this;\n        const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n        views.bufferCtx.beginPath();\n        views.bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        views.bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        views.bufferCtx.strokeStyle = this.color;\n        views.bufferCtx.lineWidth = 5;\n        views.bufferCtx.lineCap = 'round';\n        views.bufferCtx.stroke();\n        views.bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        this.views.draw();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default PaintTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nclass PanTool {\n    constructor(views) {\n        this.isPanStart = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isPanStart = true;\n            const { canvas, views } = this;\n            const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx, views } = this;\n            e.preventDefault();\n            if (!this.isPanStart)\n                return;\n            const currentTransformedCursor = getTransformedPoints(e, views.canvas, views.ctx);\n            const point = new Point(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.paning(point);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx, views } = this;\n            this.isPanStart = false;\n        };\n        this.canvas = views.canvas;\n        this.ctx = views.ctx;\n        this.lastPoint = new Point(0, 0);\n        this.views = views;\n        this.registerEvent(views.canvas);\n    }\n    paning(point) {\n        const { ctx, views, canvas } = this;\n        const OutsideRect = canvas.getBoundingClientRect();\n        ctx.translate(point.x - this.lastPoint.x, point.y - this.lastPoint.y);\n        const materix = ctx.getTransform();\n        // if (\n        //   IsOverBoundRect(\n        //     materix.e,\n        //     materix.f,\n        //     materix.e + canvas.width * materix.a,\n        //     materix.f + canvas.height * materix.d,\n        //     0,\n        //     0,\n        //     canvas.width,\n        //     canvas.height,\n        //   ) &&\n        //   getCurrentZoom(ctx) < 1\n        // ) {\n        //   return;\n        // }\n        views.draw();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default PanTool;\n","import EraseTool from './Erase';\nimport PaintTool from './Paint';\nimport PanTool from './Pan';\nexport const Tools = {\n    PaintTool,\n    EraseTool,\n    PanTool,\n};\nexport default function dynamicClass(name) {\n    return Tools[name];\n}\n","import React, { useRef, useEffect, useState } from 'react';\nimport Button from '../Button';\nimport dynamicClass from '~/canvas/ImageEditor/Tool';\nimport Views from '~/canvas/ImageEditor/Canvas/Canvas';\nimport Menu from './Menu';\nconst CanvasImageEditor = (props) => {\n    const canvasRef = useRef(null);\n    const [file, setFile] = useState(null);\n    const [mode, setMode] = useState(null);\n    const ViewsRef = useRef(new Views());\n    const ContentRef = useRef();\n    const onClickFile = (e) => {\n        setFile(e.target.files[0]);\n    };\n    const onDeleteFile = (e) => {\n        setFile(null);\n    };\n    const onDraw = () => {\n        setMode('PaintTool');\n    };\n    const onErase = () => {\n        setMode('EraseTool');\n    };\n    const onPan = () => {\n        setMode('PanTool');\n    };\n    useEffect(() => {\n        if (canvasRef.current && file !== null) {\n            ViewsRef.current.loadFile(file);\n        }\n        return () => ViewsRef.current.cleanCanvas();\n    }, [file]);\n    useEffect(() => {\n        if (canvasRef.current && file !== null) {\n            // const ctx = paintCanvasRef.current.getContext('2d');\n            const ToolClass = dynamicClass(mode);\n            let tool = new ToolClass(ViewsRef.current);\n            return () => {\n                tool.unRegisterEvent(ViewsRef.current.canvas);\n            };\n        }\n    }, [mode]);\n    useEffect(() => {\n        if (canvasRef.current) {\n            ViewsRef.current.initializeCanvas(canvasRef.current);\n            updateDimensions();\n            window.addEventListener('resize', updateDimensions);\n            return () => window.removeEventListener('resize', updateDimensions);\n        }\n    }, []);\n    const updateDimensions = () => {\n        canvasRef.current.width = ContentRef.current.offsetWidth;\n        canvasRef.current.height = ContentRef.current.offsetHeight;\n        // ViewsRef.current.draw();\n    };\n    return (React.createElement(React.Fragment, null,\n        React.createElement(\"div\", { ref: ContentRef, className: ` relative border-solid border-yellow-400` },\n            file === null && (React.createElement(\"div\", { className: \"absolute inset-0 flex items-center justify-center\" },\n                React.createElement(\"div\", { className: \" text-white\" }, \"please click or drag file\"),\n                React.createElement(\"input\", { onChange: onClickFile, className: \" absolute inset-0 z-10 cursor-pointer opacity-0\", type: \"file\", accept: \"image/*\" }))),\n            React.createElement(\"canvas\", { ...props, ref: canvasRef })),\n        React.createElement(\"div\", { className: \"flex w-full space-x-3\" },\n            React.createElement(Button, { onClick: onDeleteFile }, \" delete File\"),\n            React.createElement(Button, { onClick: onDraw }, \" draw mode\"),\n            React.createElement(Button, { onClick: onPan }, \" Pan mode\"),\n            React.createElement(Button, { onClick: onErase }, \" Erase mode\")),\n        React.createElement(Menu, null)));\n};\nexport default CanvasImageEditor;\n","import React, { useRef, useState } from 'react';\nimport { Brush } from '@mui/icons-material';\nconst Menu = () => {\n    const [menu, setMenu] = useState(false);\n    const menuRef = useRef(null);\n    return React.createElement(\"div\", { className: \" absolute inset-y-0 left-0\" }, React.createElement(Brush, null));\n};\nexport default Menu;\n","import React from 'react';\nimport CanvasImageEditor from '~/components/ImageEditor/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: \"relative m-auto flex w-full flex-col items-center justify-center\" },\n        React.createElement(CanvasImageEditor, { className: \" h-[100vh] w-[80vw] border border-solid border-white\" })));\n};\nexport default ImageEditor;\n","export function getCurrentZoom(ctx) {\n    // Extract the current transformation matrix from the context\n    const matrix = ctx.getTransform();\n    // Calculate the current zoom level as the square root of the determinant of the transformation matrix\n    // (see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/determinant)\n    return Math.sqrt(Math.abs(matrix.a * matrix.d - matrix.b * matrix.c));\n}\nexport function redrawBoundBackGround(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\n","export function getClientOffset(e, canvas, scale = 1, offsetPoint) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    // var offsetX=canvasOffset.left;\n    // var offsetY=canvasOffset.top;\n    const rect = canvas.getBoundingClientRect();\n    // console.log(rect);\n    console.log(`pageX: ${pageX}`);\n    console.log(`offsetLeft: ${e}`);\n    console.log(`scale:${scale}`);\n    // const x = pageX - rect.left;\n    // const y = pageY - rect.top;\n    const x = (pageX - rect.left - canvas.width / 2) / scale + canvas.width / 2;\n    const y = (pageY - rect.top - canvas.height / 2) / scale + canvas.height / 2;\n    console.log(`final:${x}`);\n    return {\n        x,\n        y,\n    };\n}\n// export function getTransformedPoint(e, ctx: CanvasRenderingContext2D) {\n//   const { offsetx: pageX, offsetY: pageY } = e.touches ? e.touches[0] : e;\n//   const originalPoint = new DOMPoint(e.offsetx, e.offsetY);\n//   return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n// }\nexport function getTransformedPoint(e, canvas, ctx) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const originalPoint = new DOMPoint(offsetX, offsetY);\n    // const t = ctx.getTransform();\n    // console.log(t);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPaintPoint(e, canvas, ctx, scale = 1) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    console.log(ctx.getTransform());\n    const originalPoint = new DOMPoint(offsetX - rect.left, offsetY, rect.top);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPoints(e, canvas, ctx) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const originalPoint = new DOMPoint(pageX - rect.left, pageY - rect.top);\n    const point = ctx.getTransform().invertSelf().transformPoint(originalPoint);\n    const x = point.x;\n    const y = point.y;\n    return { x: x, y: y };\n}\n"],"names":[],"sourceRoot":""}