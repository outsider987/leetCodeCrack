{"version":3,"file":"75b051028235534d415a.js","mappings":";;;;;;;;;;;;;;;;AAA8D;AACzB;AACrC;AACA,iBAAiB,6CAAM;AACvB,YAAY,YAAY,EAAE,qDAAW;AACrC,YAAY,sGAAsG;AAClH,yBAAyB,6CAAM;AAC/B,IAAI,gDAAS;AACb;AACA;AACA,oBAAoB,wCAAwC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,kDAAW;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA,yBAAyB;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,0DAAmB;AAC/B;AACA,6CAA6C,0DAAmB,UAAU,oCAAoC;AAC9G,gBAAgB,0DAAmB,UAAU,kBAAkB;AAC/D,QAAQ,0DAAmB,UAAU,wCAAwC;AAC7E;AACA,iEAAe,cAAc,EAAC","sources":["webpack://leetcodecrack/./src/pages/Home/Performance/InfiniteScroll.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useRef } from 'react';\nimport usePostsApi from '~/api/post';\nconst InfiniteScroll = () => {\n    const page = useRef(1);\n    const { GET_POSTS } = usePostsApi();\n    const { data, isSuccess, isFetchingNextPage, fetchNextPage, fetchPreviousPage, hasNextPage, hasPreviousPage } = GET_POSTS(1);\n    const observerElem = useRef(null);\n    useEffect(() => {\n        let fetching = false;\n        const handleScroll = async (e) => {\n            const { scrollHeight, scrollTop, clientHeight } = e.target.scrollingElement;\n            if (!fetching && scrollHeight - scrollTop <= clientHeight * 1.2) {\n                fetching = true;\n                if (hasNextPage)\n                    await fetchNextPage();\n                fetching = false;\n            }\n        };\n        document.addEventListener('scroll', handleScroll);\n        return () => {\n            document.removeEventListener('scroll', handleScroll);\n        };\n    }, [fetchNextPage, hasNextPage]);\n    const handleObserver = useCallback((entries) => {\n        const [target] = entries;\n        if (target.isIntersecting) {\n            fetchNextPage();\n        }\n    }, [fetchNextPage, hasNextPage]);\n    useEffect(() => {\n        const element = observerElem.current;\n        const option = { threshold: 0 };\n        const observer = new IntersectionObserver(handleObserver, option);\n        observer.observe(element);\n        return () => observer.unobserve(element);\n    }, [fetchNextPage, hasNextPage, handleObserver]);\n    const len = data?.pages.length;\n    return (React.createElement(\"div\", null,\n        isSuccess &&\n            data.pages.flat().map((post) => (React.createElement(\"div\", { className: \"result\", key: post?.id },\n                React.createElement(\"img\", { src: post?.image })))),\n        React.createElement(\"div\", { className: \"loader\", ref: observerElem }, isFetchingNextPage && hasNextPage ? 'Loading...' : 'No search left')));\n};\nexport default InfiniteScroll;\n"],"names":[],"sourceRoot":""}