{"version":3,"file":"eb0a0aa070a09c7d9314.js","mappings":";;;;;;;;;;;;;;;AAAiD;AACjD;AACA,sBAAsB,6CAAM;AAC5B;AACA,UAAU,8CAA8C;AACxD,UAAU,6CAA6C;AACvD,UAAU,mDAAmD;AAC7D,UAAU,8CAA8C;AACxD,UAAU,yCAAyC;AACnD;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,oDAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,0DAAmB,aAAa,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC;AACtB,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA,SAAS,8CAA8C;AACvD,SAAS,6CAA6C;AACtD,SAAS,mDAAmD;AAC5D,SAAS,8CAA8C;AACvD;AACA,sDAAsD,OAAO;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,UAAU,KAAK,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1J0B;AACe;AACzC;AACA,YAAY,0DAAmB,UAAU,yCAAyC;AAClF,QAAQ,0DAAmB,CAAC,0DAAM;AAClC;AACA,iEAAe,KAAK,EAAC","sources":["webpack://leetcodecrack/./src/components/Canvas.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/Chart.tsx"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nconst Canvas = (props) => {\n    const canvasRef = useRef(null);\n    const results = [\n        { mood: 'Angry', total: 1499, color: '#0a9627' },\n        { mood: 'Happy', total: 478, color: '#960A2C' },\n        { mood: 'Melancholic', total: 332, color: '#332E2E' },\n        { mood: 'Gloomy', total: 195, color: '#F73809' },\n        { mood: 'Test', total: 195, color: 'pink' },\n    ];\n    let totalNumber = results.reduce((sum, { total }) => sum + total, 0);\n    let lastValue = 0;\n    const datas = results.map((result) => {\n        const lastPercentage = (lastValue / totalNumber) * 100;\n        const percentage = Math.round(lastPercentage + (result.total / totalNumber) * 100);\n        lastValue += result.total;\n        return {\n            percentage,\n            color: result.color,\n            startAngle: Math.round((-Math.PI / 2 + (Math.PI * 2 * lastPercentage) / 100) * 100) / 100,\n        };\n    });\n    useEffect(() => {\n        let currentAngle = 0;\n        if (canvasRef.current) {\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            var cw = canvas.width;\n            var ch = canvas.height;\n            var nextTime = 0;\n            var duration = 1000;\n            var endingPct = 100;\n            var pct = 0;\n            var increment = duration / pct;\n            var cx = cw / 2;\n            var cy = ch / 2;\n            var img = new Image();\n            img.onload = start;\n            img.src = require('~/assets/img/me.jpg');\n            function start() {\n                requestAnimationFrame(animate);\n            }\n            function animate(time) {\n                draw(pct);\n                pct++;\n                if (pct <= endingPct) {\n                    requestAnimationFrame(animate);\n                }\n            }\n            function draw(pct) {\n                var endRadians = -Math.PI / 2 + (Math.PI * 2 * pct) / 100;\n                for (let moodValue of datas) {\n                    ctx.fillStyle = moodValue.color;\n                    if (endRadians >= moodValue.startAngle && pct <= moodValue.percentage) {\n                        if (moodValue.color === '#0a9627') {\n                            // debugger;\n                        }\n                        ctx.beginPath();\n                        ctx.arc(cx, cy, 100, moodValue.startAngle, endRadians);\n                        ctx.lineTo(cx, cy);\n                        ctx.save();\n                        ctx.clip();\n                        ctx.fillStyle = moodValue.color;\n                        ctx.fill();\n                        ctx.restore();\n                    }\n                }\n            }\n        }\n    }, []);\n    return React.createElement(\"canvas\", { ...props, ref: canvasRef });\n};\nCanvas.defaultProps = {\n    width: window.innerWidth / 2,\n    height: window.innerHeight / 2,\n};\nexport default Canvas;\n// import React, { useRef, useEffect } from 'react';\n// interface CanvasProps extends React.HTMLAttributes<HTMLCanvasElement> {}\n// const Canvas = (props: CanvasProps) => {\n//   const canvasRef = useRef<HTMLCanvasElement>(null);\n//   const results = [\n//     { mood: 'Angry', total: 1499, shade: '#0a9627' },\n//     { mood: 'Happy', total: 478, shade: '#960A2C' },\n//     { mood: 'Melancholic', total: 332, shade: '#332E2E' },\n//     { mood: 'Gloomy', total: 195, shade: '#F73809' },\n//   ];\n//   let totalNumberOfPeople = results.reduce((sum, { total }) => sum + total, 0);\n//   useEffect(() => {\n//     let currentAngle = 0;\n//     if (canvasRef.current) {\n//       const canvas = canvasRef.current;\n//       const ctx = canvas.getContext('2d');\n//       var cw = canvas.width;\n//       var ch = canvas.height;\n//       var nextTime = 0;\n//       var duration = 1000;\n//       var endingPct = 75;\n//       var pct = 0;\n//       var increment = duration / pct;\n//       var cx = cw / 2;\n//       var cy = ch / 2;\n//       var img = new Image();\n//       img.onload = start;\n//       img.src = require('~/assets/img/me.jpg');\n//       function start() {\n//         requestAnimationFrame(animate);\n//       }\n//       function animate(time) {\n//         draw(pct);\n//         pct++;\n//         if (pct <= endingPct) {\n//           requestAnimationFrame(animate);\n//         }\n//       }\n//       function draw(pct) {\n//         // //\n//         // var endRadians = -Math.PI / 2 + (Math.PI * 2 * pct) / 100;\n//         // //\n//         // ctx.fillStyle = 'black';\n//         // ctx.fillRect(0, 0, cw, ch);\n//         // //\n//         // ctx.beginPath();\n//         // ctx.arc(cx, cy, 100, -Math.PI / 2, endRadians);\n//         // ctx.lineTo(cx, cy);\n//         // ctx.save();\n//         // ctx.clip();\n//         // ctx.drawImage(img, cx - img.width / 2, cx - img.height / 2);\n//         // ctx.restore();\n//         for (let moodValue of results) {\n//           //calculating the angle the slice (portion) will take in the chart\n//           let portionAngle = (moodValue.total / totalNumberOfPeople) * 2 * Math.PI;\n//           //drawing an arc and a line to the center to differentiate the slice from the rest\n//           ctx.beginPath();\n//           ctx.arc(100, 100, 100, currentAngle, currentAngle + portionAngle);\n//           currentAngle += portionAngle;\n//           ctx.lineTo(100, 100);\n//           ctx.save();\n//           ctx.clip();\n//           //filling the slices with the corresponding mood's color\n//           ctx.fillStyle = moodValue.shade;\n//           ctx.fill();\n//           ctx.restore();\n//         }\n//       }\n//       //   start();\n//     }\n//   }, []);\n//   return <canvas {...props} ref={canvasRef} />;\n// };\n// Canvas.defaultProps = {\n//   width: window.innerWidth / 2,\n//   height: window.innerHeight / 2,\n// };\n// export default Canvas;\n","import React from 'react';\nimport Canvas from '~/components/Canvas';\nconst Chart = () => {\n    return (React.createElement(\"div\", { className: \"m-auto flex justify-center\" },\n        React.createElement(Canvas, null)));\n};\nexport default Chart;\n"],"names":[],"sourceRoot":""}