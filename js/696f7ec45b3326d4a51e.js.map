{"version":3,"file":"696f7ec45b3326d4a51e.js","mappings":";;;;;;;;;;;;;;;;AAAwB;AACE;AAC1B;AACA,YAAY,iDAAiD;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B,YAAY,0DAAmB,YAAY,2HAA2H;AACtK;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;;ACvBD;AACO;AACjC;AACA,YAAY,4CAA4C;AACxD,wCAAwC,+CAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA,sBAAsB,WAAW;AACjC;AACA,YAAY,0DAAmB,UAAU,2DAA2D;AACpG,QAAQ,0DAAmB,UAAU,2CAA2C,UAAU,WAAW,kCAAkC;AACvI,QAAQ,0DAAmB,UAAU,8BAA8B,gCAAgC,0BAA0B;AAC7H,YAAY,0DAAmB,UAAU,uEAAuE;AAChH,QAAQ,0DAAmB,YAAY,mSAAmS;AAC1U;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;AC9BI;AACwD;AAClF;AACA,YAAY,0DAAmB,UAAU,mGAAmG;AAC5I,QAAQ,0DAAmB,CAAC,wFAAiB,IAAI,sFAAsF;AACvI;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;ACNpB,sBAAsB;;;;;;;;;;;;;;;;;ACAtB;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrBO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;ACLgC;AACQ;AACjC;AACP;AACA,IAAI,kDAAc,CAAC,qDAAQ,GAAG,kCAAkC;AAChE,uCAAuC;AACvC;AACO;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACO;AACP;AACA,IAAI,kDAAc,CAAC,qDAAQ,GAAG,0DAA0D;AACxF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb","sources":["webpack://leetcodecrack/./src/components/NumberInput.tsx","webpack://leetcodecrack/./src/components/Slider.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/constants.ts","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts","webpack://leetcodecrack/./src/utils/canvas/mainCanvas.ts","webpack://leetcodecrack/./src/utils/canvas/rect.ts","webpack://leetcodecrack/./src/utils/image.ts","webpack://leetcodecrack/./src/utils/storage.ts"],"sourcesContent":["import clsx from 'clsx';\nimport React from 'react';\nconst NumberInput = (props) => {\n    const { min = 0, max = 100, value, setValue, className } = props;\n    const handleChange = (event) => {\n        const newValue = parseInt(event.target.value, 10);\n        if (!isNaN(newValue) && newValue >= min && newValue <= max) {\n            setValue(newValue);\n        }\n    };\n    const handleKeyDown = (event) => {\n        if (event.key === 'ArrowUp') {\n            event.preventDefault();\n            setValue(Math.min(value + 1, max));\n        }\n        else if (event.key === 'ArrowDown') {\n            event.preventDefault();\n            setValue(Math.max(value - 1, min));\n        }\n    };\n    const inputClasses = clsx(className, 'flex-1', 'w-full', 'rounded-lg', 'border-2', 'border-solid', 'border-white', 'bg-black', 'px-2', 'pt-2', 'pb-2', 'text-sm', 'text-white', 'focus:border-orange-400', 'focus:outline-none');\n    return (React.createElement(\"input\", { type: \"text\", value: value, onChange: handleChange, className: inputClasses, min: min, max: max, onKeyDown: handleKeyDown }));\n};\nexport default NumberInput;\n","import React from 'react';\nimport { useState } from 'react';\nconst Slider = (props) => {\n    const { setSizeCallBack, min = 1, max = 100, size } = props;\n    const [isDragging, setIsDragging] = useState(false);\n    const handleChange = (event) => {\n        const newValue = event.target.value;\n        const value = min && newValue < min ? min : max && newValue > max ? max : newValue;\n        setSizeCallBack(value);\n    };\n    const handleDragStart = () => {\n        setIsDragging(true);\n    };\n    const handleDragEnd = () => {\n        setIsDragging(false);\n    };\n    const percentage = (size / max) * 100;\n    const volumeGradient = `linear-gradient(to right, \n      rgba(255, 212, 71, 1) 0%, \n      rgba(255, 161, 71, 1) ${percentage}%, \n      rgba(255, 84, 84, 1) 100%)`;\n    const circlePosition = {\n        left: `calc(${percentage}% - 7px)`,\n    };\n    return (React.createElement(\"div\", { className: \"relative h-4 w-full rounded-full bg-gray-800\" },\n        React.createElement(\"div\", { className: \"h-full rounded-full\", style: { width: `${percentage}%`, background: volumeGradient } }),\n        React.createElement(\"div\", { className: `absolute top-0  ${isDragging ? 'block' : 'hidden'}`, style: circlePosition },\n            React.createElement(\"div\", { className: \"h-4 w-4 rounded-full border-2 border-yellow-500 bg-white\" })),\n        React.createElement(\"input\", { type: \"range\", min: min, max: max, value: size, onChange: handleChange, onMouseDown: handleDragStart, onTouchStart: handleDragStart, onTouchEnd: handleDragEnd, onTouchCancel: handleDragEnd, onMouseUp: handleDragEnd, className: \"absolute top-0 left-0 h-full w-full cursor-pointer opacity-0\" })));\n};\nexport default Slider;\n","import React from 'react';\nimport CanvasImageEditor from '~/canvas/components/ImageEditor/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: `relative m-auto flex h-full max-h-screen w-full flex-col items-center justify-center` },\n        React.createElement(CanvasImageEditor, { className: \"relative  flex h-full w-full  flex-row border border-solid border-white\" })));\n};\nexport default ImageEditor;\n","export const LAYOUT_SIZE = { MENU_WIDTH: '2.5rem', PANEL_WIDTH: '10rem' };\n","export function getTransformedPoint(e, canvas, ctx) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const originalPoint = new DOMPoint(offsetX, offsetY);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPaintPoint(e, canvas, ctx, scale = 1) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    console.log(ctx.getTransform());\n    const originalPoint = new DOMPoint(offsetX - rect.left, offsetY, rect.top);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPoints(e, canvas, ctx) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const originalPoint = new DOMPoint(pageX - rect.left, pageY - rect.top);\n    const point = ctx.getTransform().invertSelf().transformPoint(originalPoint);\n    const x = point.x;\n    const y = point.y;\n    return { x: x, y: y };\n}\n","export function getCurrentZoom(ctx) {\n    // Extract the current transformation matrix from the context\n    const matrix = ctx.getTransform();\n    // Calculate the current zoom level as the square root of the determinant of the transformation matrix\n    // (see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/determinant)\n    return Math.sqrt(Math.abs(matrix.a * matrix.d - matrix.b * matrix.c));\n}\nexport function redrawBoundBackGround(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\nexport function updateCanvasSize(mianCanvas, cursorCanvas, width, height) {\n    mianCanvas.width = width;\n    mianCanvas.height = height;\n    cursorCanvas.width = width;\n    cursorCanvas.height = height;\n}\n","export function IsInRect(x, y, left, top, right, bottom) {\n    return x >= left && x <= right && y >= top && y <= bottom;\n}\nexport function IsOutRect(x, y, left, top, right, bottom) {\n    return x < left || x > right || y < top || y > bottom;\n}\nexport function IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n    return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n}\nexport function getNewSize(canvas, image) {\n    const widthRatio = canvas.width / image.width;\n    const heightRatio = canvas.height / image.height;\n    // Use the smaller ratio to ensure that the image fits inside the canvas\n    const scale = Math.min(widthRatio, heightRatio);\n    // Calculate the new width and height of the image\n    const newWidth = image.width * scale;\n    const newHeight = image.height * scale;\n    return { newWidth, newHeight };\n}\n","export function onload2promise(obj) {\n    return new Promise((resolve, reject) => {\n        obj.onload = () => resolve(obj);\n        obj.onerror = reject;\n    });\n}\n","import { store } from '~/store';\nimport { setToken } from '~/store/auth';\nexport const setTokenStorage = (tokens) => {\n    localStorage.setItem('tokens', JSON.stringify(tokens));\n    store.dispatch(setToken({ ...tokens, userInformation: null }));\n    // store.dispatch(setTokenConfig({}));\n};\nexport const getTokenStorage = () => {\n    const tokens = localStorage.getItem('tokens');\n    if (tokens == undefined)\n        return { accessToken: '', refreshToken: '' };\n    if (tokens)\n        return JSON.parse(tokens);\n    return '';\n};\nexport const cleanTokenStorage = () => {\n    localStorage.removeItem('tokens');\n    store.dispatch(setToken({ accessToken: '', refreshToken: '', userInformation: null }));\n};\nexport const useGlobalStorage = () => {\n    const key = 'global_state';\n    const setGlobalStorage = (dataObject) => {\n        sessionStorage.setItem(key, JSON.stringify(dataObject));\n    };\n    const getGlobalStorage = () => {\n        const value = sessionStorage.getItem(key);\n        if (value == undefined)\n            return null;\n        if (value)\n            return JSON.parse(value);\n        return null;\n    };\n    const removeGlobalStorage = () => {\n        sessionStorage.removeItem(key);\n    };\n    return { setGlobalStorage, getGlobalStorage, removeGlobalStorage };\n};\n"],"names":[],"sourceRoot":""}