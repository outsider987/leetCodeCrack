{"version":3,"file":"519aaf1af3164f89a16e.js","mappings":";;;;;;;;;;;;;;;AAA0B;AACO;AACjC;AACA,YAAY,sCAAsC;AAClD,8BAA8B,+CAAQ;AACtC,wCAAwC,+CAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,MAAM;AACpC;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA,YAAY,0DAAmB,UAAU,2DAA2D;AACpG,QAAQ,0DAAmB,UAAU,2CAA2C,UAAU,MAAM,kCAAkC;AAClI,QAAQ,0DAAmB,UAAU,8BAA8B,gCAAgC,0BAA0B;AAC7H,YAAY,0DAAmB,UAAU,uEAAuE;AAChH,QAAQ,0DAAmB,YAAY,oSAAoS;AAC3U;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;;;;AC/BI;AACwD;AAClF;AACA,YAAY,0DAAmB,UAAU,mGAAmG;AAC5I,QAAQ,0DAAmB,CAAC,wFAAiB,IAAI,sFAAsF;AACvI;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;;ACNpB;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACfO,sBAAsB;;;;;;;;;;;;;;;;;ACAtB;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACO;AACP,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;;;;ACpBO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;;;;;;;;;;;;;;AClBO;AACP;AACA;AACA;AACA,KAAK;AACL","sources":["webpack://leetcodecrack/./src/components/Slider.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/canvas.ts","webpack://leetcodecrack/./src/utils/canvas/constants.ts","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts","webpack://leetcodecrack/./src/utils/canvas/rect.ts","webpack://leetcodecrack/./src/utils/image.ts"],"sourcesContent":["import React from 'react';\nimport { useState } from 'react';\nconst Slider = (props) => {\n    const { setSizeCallBack, min = 1, max = 100 } = props;\n    const [value, setValue] = useState(50);\n    const [isDragging, setIsDragging] = useState(false);\n    const handleChange = (event) => {\n        const newValue = event.target.value;\n        const value = min && newValue < min ? min : max && newValue > max ? max : newValue;\n        setValue(value);\n        setSizeCallBack(value);\n    };\n    const handleDragStart = () => {\n        setIsDragging(true);\n    };\n    const handleDragEnd = () => {\n        setIsDragging(false);\n    };\n    const volumeGradient = `linear-gradient(to right, \n      rgba(255, 212, 71, 1) 0%, \n      rgba(255, 161, 71, 1) ${value}%, \n      rgba(255, 84, 84, 1) 100%)`;\n    const circlePosition = {\n        left: `calc(${value}% - 7px)`,\n    };\n    return (React.createElement(\"div\", { className: \"relative h-4 w-full rounded-full bg-gray-800\" },\n        React.createElement(\"div\", { className: \"h-full rounded-full\", style: { width: `${value}%`, background: volumeGradient } }),\n        React.createElement(\"div\", { className: `absolute top-0  ${isDragging ? 'block' : 'hidden'}`, style: circlePosition },\n            React.createElement(\"div\", { className: \"h-4 w-4 rounded-full border-2 border-yellow-500 bg-white\" })),\n        React.createElement(\"input\", { type: \"range\", min: min, max: max, value: value, onChange: handleChange, onMouseDown: handleDragStart, onTouchStart: handleDragStart, onTouchEnd: handleDragEnd, onTouchCancel: handleDragEnd, onMouseUp: handleDragEnd, className: \"absolute top-0 left-0 h-full w-full cursor-pointer opacity-0\" })));\n};\nexport default Slider;\n","import React from 'react';\nimport CanvasImageEditor from '~/canvas/components/ImageEditor/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: `relative m-auto flex h-full max-h-screen w-full flex-col items-center justify-center` },\n        React.createElement(CanvasImageEditor, { className: \"relative  flex h-full w-full  flex-row border border-solid border-white\" })));\n};\nexport default ImageEditor;\n","export function getCurrentZoom(ctx) {\n    // Extract the current transformation matrix from the context\n    const matrix = ctx.getTransform();\n    // Calculate the current zoom level as the square root of the determinant of the transformation matrix\n    // (see https://developer.mozilla.org/en-US/docs/Web/API/DOMMatrix/determinant)\n    return Math.sqrt(Math.abs(matrix.a * matrix.d - matrix.b * matrix.c));\n}\nexport function redrawBoundBackGround(canvas) {\n    const ctx = canvas.getContext('2d');\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = 'grey';\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.restore();\n}\n","export const LAYOUT_SIZE = { MENU_WIDTH: '2.5rem', PANEL_WIDTH: '10rem' };\n","export function getTransformedPoint(e, canvas, ctx) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const originalPoint = new DOMPoint(offsetX, offsetY);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPaintPoint(e, canvas, ctx, scale = 1) {\n    const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    console.log(ctx.getTransform());\n    const originalPoint = new DOMPoint(offsetX - rect.left, offsetY, rect.top);\n    return ctx.getTransform().invertSelf().transformPoint(originalPoint);\n}\nexport function getTransformedPoints(e, canvas, ctx) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const originalPoint = new DOMPoint(pageX - rect.left, pageY - rect.top);\n    const point = ctx.getTransform().invertSelf().transformPoint(originalPoint);\n    const x = point.x;\n    const y = point.y;\n    return { x: x, y: y };\n}\n","export function IsInRect(x, y, left, top, right, bottom) {\n    return x >= left && x <= right && y >= top && y <= bottom;\n}\nexport function IsOutRect(x, y, left, top, right, bottom) {\n    return x < left || x > right || y < top || y > bottom;\n}\nexport function IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n    return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n}\nexport function getNewSize(canvas, image) {\n    const widthRatio = canvas.width / image.width;\n    const heightRatio = canvas.height / image.height;\n    // Use the smaller ratio to ensure that the image fits inside the canvas\n    const scale = Math.min(widthRatio, heightRatio);\n    // Calculate the new width and height of the image\n    const newWidth = image.width * scale;\n    const newHeight = image.height * scale;\n    return { newWidth, newHeight };\n}\n","export function onload2promise(obj) {\n    return new Promise((resolve, reject) => {\n        obj.onload = () => resolve(obj);\n        obj.onerror = reject;\n    });\n}\n"],"names":[],"sourceRoot":""}