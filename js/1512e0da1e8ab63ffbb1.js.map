{"version":3,"file":"1512e0da1e8ab63ffbb1.js","mappings":";;;;;;;;;;;;;;AAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,yEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;ACzHuC;AAC7B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0BAA0B;AAC1C;AACA,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA,4BAA4B,yEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;AC7IrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;ACVuC;AAC/B;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8CAAK;AACnC;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;ACtEmC;AAC7B;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,4BAA4B,yEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AC1EQ;AACF;AACvB;AACP,cAAc,6CAAQ;AACtB,eAAe,8CAAS;AACxB;AACe;AACf;AACA;;;;;;;;;;;;;;;;;;;;;ACR2D;AAC5B;AACsB;AACE;AACF;AACrD;AACA,sBAAsB,6CAAM;AAC5B,4BAA4B,6CAAM;AAClC,2BAA2B,6CAAM;AACjC,4BAA4B,+CAAQ;AACpC,4BAA4B,+CAAQ;AACpC,qBAAqB,6CAAM,KAAK,yEAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA,8BAA8B,uEAAK;AACnC;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA,8BAA8B,oEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA,KAAK;AACL,YAAY,0DAAmB,CAAC,uDAAc;AAC9C,QAAQ,0DAAmB,UAAU,uDAAuD;AAC5F,8BAA8B,0DAAmB,UAAU,gEAAgE;AAC3H,gBAAgB,0DAAmB,UAAU,0BAA0B;AACvE,gBAAgB,0DAAmB,YAAY,sHAAsH;AACrK,YAAY,0DAAmB,aAAa,0FAA0F;AACtI,YAAY,0DAAmB,aAAa,gGAAgG;AAC5I,YAAY,0DAAmB,aAAa,+FAA+F;AAC3I,QAAQ,0DAAmB,UAAU,oCAAoC;AACzE,YAAY,0DAAmB,CAAC,+CAAM,IAAI,uBAAuB;AACjE,YAAY,0DAAmB,CAAC,+CAAM,IAAI,iBAAiB;AAC3D,YAAY,0DAAmB,CAAC,+CAAM,IAAI,kBAAkB;AAC5D;AACA,iEAAe,iBAAiB,EAAC;;;;;;;;;;;;;;;;;;AC1EP;AAC2C;AACrE;AACA,YAAY,0DAAmB,UAAU,sEAAsE;AAC/G,QAAQ,0DAAmB,CAAC,2EAAiB,IAAI,iDAAiD;AAClG;AACA,iEAAe,WAAW,EAAC;;;;;;;;;;;;;;;ACNpB;AACP,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Canvas/Canvas.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Layer/Layer.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Point.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Erase.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Line.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/index.ts","webpack://leetcodecrack/./src/components/Chart/CanvasImageEditor.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/ImageEditor.tsx","webpack://leetcodecrack/./src/utils/canvas/coordinate.ts"],"sourcesContent":["import { getClientOffset } from '~/utils/canvas/coordinate';\nclass Views {\n    constructor() {\n        this.isDrawStart = false;\n        this.zoomLevel = 1;\n        this.lastView = null;\n        this.layerArray = [];\n        this.mouseDown = (e) => {\n            // e.preventDefault();\n            const clientPoint = getClientOffset(e, this.canvas);\n            this.lastPoint.setPoint(clientPoint.x, clientPoint.y);\n            this.isDrawStart = true;\n        };\n        this.mouseMove = (e) => {\n            // e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            // this.lineCoordinates = this.getClientOffset(event);\n            this.clearCanvas();\n        };\n        this.mouseUp = (e) => {\n            // e.preventDefault();\n            this.isDrawStart = false;\n        };\n        this.clearCanvas = () => {\n            // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        };\n    }\n    initializeCanvas(canvas) {\n        this.canvas = canvas;\n        this.ctx = canvas.getContext('2d');\n    }\n    addLayer(layer) {\n        this.layerArray.push(layer);\n    }\n    draw() { }\n    zoom(e) {\n        // const { canvas, ctx, bufferCanvas } = this;\n        // let zoom = 1;\n        // // e.preventDefault();\n        // const clientPoint = getClientOffset(e, canvas);\n        // if (e.deltaY < 0) {\n        //   zoom *= 1.1;\n        // } else {\n        //   zoom *= 0.9;\n        // }\n        const { canvas, ctx, bufferCanvas } = this;\n        let MAX_ZOOM = 5;\n        let MIN_ZOOM = 0.1;\n        let SCROLL_SENSITIVITY = 0.0005;\n        // e.preventDefault();\n        const clientPoint = getClientOffset(e, canvas);\n        const zoomAmount = SCROLL_SENSITIVITY * e.deltaY;\n        this.zoomLevel += zoomAmount;\n        this.zoomLevel = Math.min(this.zoomLevel, MAX_ZOOM);\n        this.zoomLevel = Math.max(this.zoomLevel, MIN_ZOOM);\n        console.log(this.zoomLevel);\n        // let backeupCanvas = document.createElement('canvas');\n        // backeupCanvas.width = canvas.width;\n        // backeupCanvas.height = canvas.height;\n        // let newContext = backeupCanvas.getContext('2d');\n        // const lastImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // newContext.putImageData(lastImageData, 0, 0);\n        // const lastView = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // ctx.scale(zoom, zoom);\n        // ctx.setTransform(zoom, 0, 0, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        // // ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // let ratio = Math.min(canvas.width / backeupCanvas.width, canvas.height / backeupCanvas.height);\n        // let x = (canvas.width - backeupCanvas.width * ratio) / 2;\n        // let y = (canvas.height - backeupCanvas.height * ratio) / 2;\n        // // ctx.setTransform(9, 9, 9, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        // ctx.drawImage(\n        //   backeupCanvas,\n        //   0,\n        //   0,\n        //   backeupCanvas.width,\n        //   backeupCanvas.height,\n        //   x,\n        //   y,\n        //   backeupCanvas.width * ratio,\n        //   backeupCanvas.height * ratio,\n        // );\n        // test test\n        let backeupCanvas = document.createElement('canvas');\n        backeupCanvas.width = canvas.width;\n        backeupCanvas.height = canvas.height;\n        let newContext = backeupCanvas.getContext('2d');\n        const lastImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        newContext.putImageData(lastImageData, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // ctx.setTransform(zoom, 0, 0, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        ctx.translate(clientPoint.x, clientPoint.y);\n        ctx.scale(this.zoomLevel, this.zoomLevel);\n        ctx.translate(-clientPoint.x, -clientPoint.y);\n        // let ratio = Math.min(canvas.width / backeupCanvas.width, canvas.height / backeupCanvas.height);\n        // let x = (canvas.width - backeupCanvas.width * ratio) / 2;\n        // let y = (canvas.height - backeupCanvas.height * ratio) / 2;\n        // ctx.setTransform(9, 9, 9, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        ctx.drawImage(bufferCanvas, 0, 0);\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('mousedown', this.mouseDown(this));\n        canvas.removeEventListener('mousemove', this.mouseMove(this));\n        canvas.removeEventListener('mouseup', this.mouseUp(this));\n        canvas.removeEventListener('touchstart', this.mouseDown(this));\n        canvas.removeEventListener('touchmove', this.mouseMove(this));\n        canvas.removeEventListener('touchend', this.mouseUp(this));\n        canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default Views;\n","import { getClientOffset } from '~/utils/canvas/coordinate';\nimport Point from './../Point';\nclass Layer {\n    constructor(ctx, canvas) {\n        this.isDrawStart = false;\n        this.zoomLevel = 1;\n        this.lastView = null;\n        this.mouseDown = (e) => {\n            // e.preventDefault();\n            const clientPoint = getClientOffset(e, this.canvas);\n            this.lastPoint.setPoint(clientPoint.x, clientPoint.y);\n            this.isDrawStart = true;\n        };\n        this.mouseMove = (e) => {\n            // e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            // this.loadFile(e);\n            // this.lineCoordinates = this.getClientOffset(event);\n            this.clearCanvas();\n        };\n        this.mouseUp = (e) => {\n            // e.preventDefault();\n            this.isDrawStart = false;\n        };\n        this.clearCanvas = () => {\n            // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        };\n        this.ctx = ctx;\n        this.lastPoint = new Point(0, 0);\n        this.canvas = canvas;\n        this.bufferCanvas = document.createElement('canvas');\n        this.bufferCanvas.width = canvas.width;\n        this.bufferCanvas.height = canvas.height;\n        this.bufferCtx = this.bufferCanvas.getContext('2d');\n        this.drawCanvas = document.createElement('canvas');\n        this.drawCtx = this.drawCanvas.getContext('2d');\n        this.registerEvent(this.canvas);\n    }\n    loadFile(file) {\n        const { bufferCanvas, bufferCtx } = this;\n        const image = new Image();\n        const { ctx, canvas } = this;\n        image.onload = function res() {\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.fillStyle = 'white';\n            ctx.fillRect(0, 0, canvas.width, canvas.height);\n            let ratio = Math.min(canvas.width / image.width, canvas.height / image.height);\n            let x = (canvas.width - image.width * ratio) / 2;\n            let y = (canvas.height - image.height * ratio) / 2;\n            ctx.drawImage(image, 0, 0, image.width, image.height, x, y, image.width * ratio, image.height * ratio);\n            bufferCtx.drawImage(canvas, 0, 0);\n        };\n        image.src = URL.createObjectURL(file);\n    }\n    redraw() { }\n    zoom(e) {\n        // const { canvas, ctx, bufferCanvas } = this;\n        // let zoom = 1;\n        // // e.preventDefault();\n        // const clientPoint = getClientOffset(e, canvas);\n        // if (e.deltaY < 0) {\n        //   zoom *= 1.1;\n        // } else {\n        //   zoom *= 0.9;\n        // }\n        const { canvas, ctx, bufferCanvas } = this;\n        let MAX_ZOOM = 5;\n        let MIN_ZOOM = 0.1;\n        let SCROLL_SENSITIVITY = 0.0005;\n        // e.preventDefault();\n        const clientPoint = getClientOffset(e, canvas);\n        const zoomAmount = SCROLL_SENSITIVITY * e.deltaY;\n        this.zoomLevel += zoomAmount;\n        this.zoomLevel = Math.min(this.zoomLevel, MAX_ZOOM);\n        this.zoomLevel = Math.max(this.zoomLevel, MIN_ZOOM);\n        console.log(this.zoomLevel);\n        // let backeupCanvas = document.createElement('canvas');\n        // backeupCanvas.width = canvas.width;\n        // backeupCanvas.height = canvas.height;\n        // let newContext = backeupCanvas.getContext('2d');\n        // const lastImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // newContext.putImageData(lastImageData, 0, 0);\n        // const lastView = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // ctx.scale(zoom, zoom);\n        // ctx.setTransform(zoom, 0, 0, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        // // ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // let ratio = Math.min(canvas.width / backeupCanvas.width, canvas.height / backeupCanvas.height);\n        // let x = (canvas.width - backeupCanvas.width * ratio) / 2;\n        // let y = (canvas.height - backeupCanvas.height * ratio) / 2;\n        // // ctx.setTransform(9, 9, 9, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        // ctx.drawImage(\n        //   backeupCanvas,\n        //   0,\n        //   0,\n        //   backeupCanvas.width,\n        //   backeupCanvas.height,\n        //   x,\n        //   y,\n        //   backeupCanvas.width * ratio,\n        //   backeupCanvas.height * ratio,\n        // );\n        // test test\n        let backeupCanvas = document.createElement('canvas');\n        backeupCanvas.width = canvas.width;\n        backeupCanvas.height = canvas.height;\n        let newContext = backeupCanvas.getContext('2d');\n        const lastImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        newContext.putImageData(lastImageData, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n        // ctx.setTransform(zoom, 0, 0, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        ctx.translate(clientPoint.x, clientPoint.y);\n        ctx.scale(this.zoomLevel, this.zoomLevel);\n        ctx.translate(-clientPoint.x, -clientPoint.y);\n        // let ratio = Math.min(canvas.width / backeupCanvas.width, canvas.height / backeupCanvas.height);\n        // let x = (canvas.width - backeupCanvas.width * ratio) / 2;\n        // let y = (canvas.height - backeupCanvas.height * ratio) / 2;\n        // ctx.setTransform(9, 9, 9, zoom, (1 - zoom) * clientPoint.x, (1 - zoom) * clientPoint.y);\n        ctx.drawImage(bufferCanvas, 0, 0);\n    }\n    registerEvent(canvas) {\n        // canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom.bind(this));\n    }\n    unRegisterEvent(canvas) {\n        // canvas.removeEventListener('mousedown', this.mouseDown(this));\n        canvas.removeEventListener('mousemove', this.mouseMove(this));\n        canvas.removeEventListener('mouseup', this.mouseUp(this));\n        canvas.removeEventListener('touchstart', this.mouseDown(this));\n        canvas.removeEventListener('touchmove', this.mouseMove(this));\n        canvas.removeEventListener('touchend', this.mouseUp(this));\n        canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default Layer;\n","class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport default Point;\n","import { getClientOffset } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nclass EraseTool {\n    constructor(ctx, canvas) {\n        this.isDrawStart = false;\n        this.getClientOffset = (e) => {\n            const { canvas } = this;\n            const { pageX, pageY } = e.touches ? e.touches[0] : e;\n            const rect = canvas.getBoundingClientRect();\n            const x = pageX - rect.left;\n            const y = pageY - rect.top;\n            return {\n                x,\n                y,\n            };\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const clientPoint = getClientOffset(e, this.canvas);\n            this.lastPoint.setPoint(clientPoint.x, clientPoint.y);\n        };\n        this.mouseMove = (e) => {\n            e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            const clientPoint = this.getClientOffset(e);\n            const point = new Point(clientPoint.x, clientPoint.y);\n            this.erase(point);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            ctx.globalCompositeOperation = 'source-over';\n            this.isDrawStart = false;\n        };\n        this.ctx = ctx;\n        this.size = 5;\n        this.canvas = canvas;\n        this.registerEvent(canvas);\n        this.lastPoint = new Point(0, 0);\n    }\n    erase(point) {\n        const { ctx } = this;\n        ctx.globalCompositeOperation = 'destination-out';\n        ctx.beginPath();\n        ctx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        ctx.lineTo(point.x, point.y);\n        ctx.lineWidth = 20;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        this.lastPoint.setPoint(point.x, point.y);\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default EraseTool;\n","import { getClientOffset } from '~/utils/canvas/coordinate';\nimport Point from './../Point';\nclass LineTool {\n    constructor(ctx, canvas) {\n        this.isDrawStart = false;\n        this.getClientOffset = (e) => {\n            const { canvas } = this;\n            const { pageX, pageY } = e.touches ? e.touches[0] : e;\n            const rect = canvas.getBoundingClientRect();\n            const x = pageX - rect.left;\n            const y = pageY - rect.top;\n            return {\n                x,\n                y,\n            };\n        };\n        this.setColor = (color) => {\n            this.color = color;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const clientPoint = getClientOffset(e, this.canvas);\n            this.lastPoint.setPoint(clientPoint.x, clientPoint.y);\n        };\n        this.mouseMove = (e) => {\n            e.preventDefault();\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n            this.clearCanvas();\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            this.isDrawStart = false;\n        };\n        this.clearCanvas = () => {\n            // this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n        };\n        this.ctx = ctx;\n        this.lastPoint = new Point(0, 0);\n        this.setColor('white');\n        this.canvas = canvas;\n        this.registerEvent(canvas);\n    }\n    draw(e) {\n        const { canvas, ctx } = this;\n        const clientPoint = getClientOffset(e, canvas);\n        ctx.beginPath();\n        ctx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        ctx.lineTo(clientPoint.x, clientPoint.y);\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = 5;\n        ctx.lineCap = 'round';\n        ctx.stroke();\n        this.lastPoint.setPoint(clientPoint.x, clientPoint.y);\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default LineTool;\n","import EraseTool from './Erase';\nimport LineTool from './Line';\nexport const Tools = {\n    LineTool: LineTool,\n    EraseTool: EraseTool,\n};\nexport default function dynamicClass(name) {\n    return Tools[name];\n}\n","import React, { useRef, useEffect, useState } from 'react';\nimport Button from '../Button';\nimport dynamicClass from '~/canvas/ImageEditor/Tool';\nimport Views from '~/canvas/ImageEditor/Canvas/Canvas';\nimport Layer from '~/canvas/ImageEditor/Layer/Layer';\nconst CanvasImageEditor = (props) => {\n    const canvasRef = useRef(null);\n    const bufferCanvasRef = useRef(null);\n    const paintCanvasRef = useRef(null);\n    const [file, setFile] = useState(null);\n    const [mode, setMode] = useState(null);\n    const ViewsRef = useRef(new Views());\n    const onClickFile = (e) => {\n        setFile(e.target.files[0]);\n    };\n    const onDeleteFile = (e) => {\n        setFile(null);\n    };\n    const onDraw = () => {\n        setMode('LineTool');\n    };\n    const onErase = () => {\n        setMode('EraseTool');\n    };\n    // useEffect(() => {\n    //   if (canvasRef.current && file !== null) {\n    //     const canvas = canvasRef.current;\n    //     const ctx = canvasRef.current.getContext('2d');\n    //     const main = new Views(ctx, canvas);\n    //     main.loadFile(file);\n    //   } else {\n    //     const canvas = canvasRef.current;\n    //     const ctx = canvasRef.current.getContext('2d');\n    //     ctx.clearRect(0, 0, canvas.width, canvas.height);\n    //   }\n    // }, [file]);\n    useEffect(() => {\n        if (canvasRef.current && file !== null) {\n            const canvas = canvasRef.current;\n            const ctx = canvasRef.current.getContext('2d');\n            ViewsRef.current;\n            const layer = new Layer(ctx, canvas);\n            layer.loadFile(file);\n        }\n    }, [file]);\n    useEffect(() => {\n        if (canvasRef.current && file !== null) {\n            const canvas = paintCanvasRef.current;\n            const ctx = paintCanvasRef.current.getContext('2d');\n            const ToolClass = dynamicClass(mode);\n            let tool = new ToolClass(ctx, canvas);\n            return () => {\n                tool.unRegisterEvent(canvas);\n            };\n        }\n    }, [mode]);\n    useEffect(() => {\n        if (canvasRef.current) {\n            ViewsRef.current.initializeCanvas(canvasRef.current);\n        }\n    }, []);\n    return (React.createElement(React.Fragment, null,\n        React.createElement(\"div\", { className: ` relative border-solid border-yellow-400` },\n            file === null && (React.createElement(\"div\", { className: \"absolute inset-0 flex items-center justify-center\" },\n                React.createElement(\"div\", { className: \" text-white\" }, \"please click or drag file\"),\n                React.createElement(\"input\", { onChange: onClickFile, className: \" absolute inset-0 z-10 cursor-pointer opacity-0\", type: \"file\", accept: \"image/*\" }))),\n            React.createElement(\"canvas\", { ...props, ref: canvasRef, width: window.innerWidth * 0.6, height: window.innerHeight / 2 }),\n            React.createElement(\"canvas\", { ...props, ref: bufferCanvasRef, width: window.innerWidth * 0.6, height: window.innerHeight / 2 }),\n            React.createElement(\"canvas\", { ...props, ref: paintCanvasRef, width: window.innerWidth * 0.6, height: window.innerHeight / 2 })),\n        React.createElement(\"div\", { className: \"flex w-full space-x-3\" },\n            React.createElement(Button, { onClick: onDeleteFile }, \" delete File\"),\n            React.createElement(Button, { onClick: onDraw }, \" draw mode\"),\n            React.createElement(Button, { onClick: onErase }, \" Erase mode\"))));\n};\nexport default CanvasImageEditor;\n","import React from 'react';\nimport CanvasImageEditor from '~/components/Chart/CanvasImageEditor';\nconst ImageEditor = () => {\n    return (React.createElement(\"div\", { className: \"m-auto flex w-full flex-col items-center justify-center\" },\n        React.createElement(CanvasImageEditor, { className: \" border border-solid border-white \" })));\n};\nexport default ImageEditor;\n","export function getClientOffset(e, canvas) {\n    const { pageX, pageY } = e.touches ? e.touches[0] : e;\n    const rect = canvas.getBoundingClientRect();\n    const x = pageX - rect.left;\n    const y = pageY - rect.top;\n    return {\n        x,\n        y,\n    };\n}\n"],"names":[],"sourceRoot":""}