{"version":3,"file":"e069b7151e41c1cee35b.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;ACVrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACvC2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC;;;;;;;;;;;;;;;AC7F/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AC3CyC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;;;;;ACpEwC;AACpC;AACM;AACwB;AACoC;AACpE;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AACnC,uBAAuB,kDAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE,oBAAoB,mBAAmB;AACvC,qCAAqC,0EAAc,GAAG,wBAAwB;AAC9E;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D,oBAAoB,mBAAmB;AACvC,4BAA4B;AAC5B;AACA;AACA,gBAAgB,4EAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,6BAA6B,8CAAK;AAClC;AACA;AACA,4BAA4B,wEAAc;AAC1C,gCAAgC,6CAAI;AACpC,6BAA6B,6CAAI;AACjC;AACA;AACA,gBAAgB,iFAAiF;AACjG,QAAQ,yEAAa;AACrB;AACA,4BAA4B,wEAAc;AAC1C;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA,4BAA4B,wEAAc;AAC1C;AACA;AACA;AACA;AACA,gBAAgB,yFAAyF;AACzG;AACA,4BAA4B;AAC5B,6BAA6B;AAC7B,4BAA4B,wEAAc,OAAO;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;ACtKyC;AACpC;AACM;AACnC,wBAAwB,kDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,SAAS,EAAC;;;;;;;;;;;;;;;;;;ACnEwC;AACpC;AACM;AACnC,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,6CAA6C,8EAAoB;AACjE;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA,6BAA6B,8CAAK;AAClC;AACA;AACA,gBAAgB,cAAc;AAC9B,yCAAyC,8EAAoB;AAC7D;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;ACtDS;AACA;AACJ;AACE;AACvB;AACP,aAAa;AACb,aAAa;AACb,WAAW;AACX,YAAY;AACZ;AACe;AACf;AACA","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Point.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Rect.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/StateController/StateController.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/BaselTool.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Brush.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Crop.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Erase.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/Pan.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Tool/index.ts"],"sourcesContent":["class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport default Point;\n","class Rect {\n    constructor(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    setRect(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    getWidth() {\n        return this.right - this.left;\n    }\n    getHeight() {\n        return this.bottom - this.top;\n    }\n    scaleRect(level) {\n        const width = this.right - this.left;\n        const height = this.bottom - this.top;\n        // Scale the width and height based on the scaleX and scaleY parameters\n        const scaledWidth = width * level;\n        const scaledHeight = height * level;\n        // Calculate the new coordinates for the scaled rectangle\n        const scaledLeft = this.left - (scaledWidth - width) / 2;\n        const scaledTop = this.top - (scaledHeight - height) / 2;\n        const scaledRight = scaledLeft + scaledWidth;\n        const scaledBottom = scaledTop + scaledHeight;\n        this.left = scaledLeft;\n        this.top = scaledTop;\n        this.right = scaledRight;\n        this.bottom = scaledBottom;\n    }\n    IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n        return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n    }\n}\nexport default Rect;\n","import { onload2promise } from '~/utils/image';\nclass StateController {\n    constructor() {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n        this.onKeyDown = (e) => {\n            if (e.ctrlKey) {\n                if (e.key === 'z') {\n                    this.undo.apply(this);\n                }\n                if (e.key === 'y') {\n                    this.redo.apply(this);\n                }\n            }\n        };\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    initializeCanvas(views) {\n        this.canvas = views.canvas;\n        this.bufferCanvas = views.bufferCanvas;\n        this.bufferCtx = views.bufferCtx;\n        this.views = views;\n        this.registerEvent(this.canvas);\n    }\n    draw() {\n        const { views } = this;\n        views.draw();\n    }\n    async undo() {\n        const { undoStack, redoStack, bufferCtx, bufferCanvas, views } = this;\n        if (this.undoStack.length <= 1)\n            return;\n        // Remove current state from undo stack and push onto redo stack\n        const currentState = undoStack.pop();\n        redoStack.push(currentState);\n        // Load previous state from undo stack onto canvas\n        const previousState = undoStack[undoStack.length - 1] || currentState;\n        const img = new Image();\n        img.src = previousState;\n        await onload2promise(img);\n        bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);\n        bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height, 0, 0, bufferCanvas.width, bufferCanvas.height);\n        this.draw();\n    }\n    async redo() {\n        const { undoStack, redoStack, bufferCtx, bufferCanvas } = this;\n        if (redoStack.length === 0)\n            return;\n        // Remove current state from redo stack and push onto undo stack\n        const currentState = redoStack.pop();\n        undoStack.push(currentState);\n        // Load next state from redo stack onto canvas\n        const nextImage = new Image();\n        nextImage.src = currentState;\n        await onload2promise(nextImage);\n        bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);\n        bufferCtx.drawImage(nextImage, 0, 0, bufferCanvas.width, bufferCanvas.height, 0, 0, bufferCanvas.width, bufferCanvas.height);\n        this.draw();\n    }\n    cleanState() {\n        this.unRegisterEvent(this.canvas);\n        console.log('cleanState');\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    pushUndoStack() {\n        const { undoStack, canvas, bufferCanvas } = this;\n        if (bufferCanvas) {\n            undoStack.push(bufferCanvas.toDataURL());\n            this.redoStack = [];\n        }\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp.bind(this));\n        canvas.addEventListener('mouseup', this.mouseUp.bind(this));\n        window.addEventListener('keydown', this.onKeyDown);\n        // canvas.addEventListener('wheel', this.zoom.bind);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp.bind(this));\n        canvas.removeEventListener('mouseup', this.mouseUp.bind(this));\n        window.removeEventListener('keydown', this.onKeyDown);\n        // canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default StateController;\n","class BaseTool {\n    constructor(views, stateController, rasterViews) {\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n        this.views = views;\n        this.canvas = views.canvas;\n        this.bufferCanvas = views.bufferCanvas;\n        this.bufferCtx = views.bufferCtx;\n        this.ctx = views.ctx;\n        this.stateController = stateController;\n        this.rasterCanvas = rasterViews.rasterCanvas;\n        this.rasterCtx = rasterViews.rasterCtx;\n        this.rasterViews = rasterViews;\n    }\n    draw(e) {\n        const { views } = this;\n        views.draw();\n    }\n    zoom(e) { }\n    doCmd() {\n        const { stateController } = this;\n        stateController.pushUndoStack();\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoom);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n        canvas.removeEventListener('wheel', this.zoom);\n    }\n}\nexport default BaseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass BrushTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrawStart = false;\n        this.setColor = (color) => {\n            this.color = color;\n        };\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            this.isDrawStart = false;\n            this.draw(e);\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n        this.setColor('black');\n        this.size = 5;\n    }\n    draw(e) {\n        const { bufferCtx, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.strokeStyle = this.color;\n        bufferCtx.lineWidth = this.size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default BrushTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nimport { getCurrentZoom } from '~/utils/canvas/mainCanvas';\nimport { cropCursorChange, drawCropFiled, getCursorPoint, } from '~/utils/canvas/rasterCanvas';\nimport Rect from '../Rect';\nexport var CursorPoint;\n(function (CursorPoint) {\n    CursorPoint[\"left\"] = \"left\";\n    CursorPoint[\"right\"] = \"right\";\n    CursorPoint[\"top\"] = \"top\";\n    CursorPoint[\"bottom\"] = \"bottom\";\n    CursorPoint[\"topLeft\"] = \"topLeft\";\n    CursorPoint[\"topRight\"] = \"topRight\";\n    CursorPoint[\"bottomLeft\"] = \"bottomLeft\";\n    CursorPoint[\"bottomRight\"] = \"bottomRight\";\n    CursorPoint[\"move\"] = \"move\";\n})(CursorPoint || (CursorPoint = {}));\nclass CropTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrag = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrag = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n            this.currentCusorPoint = getCursorPoint({ x: offsetX, y: offsetY }, this.focusRect);\n            this.lastPoint.setPoint(offsetX, offsetY);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx, originalRect, focusRect } = this;\n            const { offsetX, offsetY } = e.touches ? e.touches[0] : e;\n            const point = { x: offsetX, y: offsetY };\n            e.preventDefault();\n            if (!this.isDrag) {\n                cropCursorChange(canvas, point, focusRect);\n                return;\n            }\n            if (this.currentCusorPoint === CursorPoint.move) {\n                const dx = offsetX - this.lastPoint.x;\n                const dy = offsetY - this.lastPoint.y;\n                //   if (\n                //     focusRect.left + dx < originalRect.left ||\n                //     focusRect.right + dx > originalRect.right ||\n                //     focusRect.top + dy < originalRect.top ||\n                //     focusRect.bottom + dy > originalRect.bottom\n                //   )\n                //     return;\n                if (focusRect.left + dx > originalRect.left || focusRect.right + dx < originalRect.right) {\n                    this.focusRect.left = Math.max(focusRect.left + dx, originalRect.left);\n                    this.focusRect.right = Math.min(focusRect.right + dx, originalRect.right);\n                }\n                this.focusRect.top += dy;\n                this.focusRect.bottom += dy;\n                this.lastPoint.setPoint(offsetX, offsetY);\n            }\n            if (this.currentCusorPoint === CursorPoint.left) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), originalRect.right);\n            }\n            if (this.currentCusorPoint === CursorPoint.top) {\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), originalRect.bottom);\n            }\n            if (this.currentCusorPoint === CursorPoint.right) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), originalRect.left);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottom) {\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), originalRect.top);\n            }\n            if (this.currentCusorPoint === CursorPoint.topLeft) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), originalRect.right);\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), originalRect.bottom);\n            }\n            if (this.currentCusorPoint === CursorPoint.topRight) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), originalRect.left);\n                this.focusRect.top = Math.min(Math.max(offsetY, originalRect.top), originalRect.bottom);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottomLeft) {\n                this.focusRect.left = Math.min(Math.max(offsetX, originalRect.left), originalRect.right);\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), originalRect.top);\n            }\n            if (this.currentCusorPoint === CursorPoint.bottomRight) {\n                this.focusRect.right = Math.max(Math.min(offsetX, originalRect.right), originalRect.left);\n                this.focusRect.bottom = Math.max(Math.min(offsetY, originalRect.bottom), originalRect.top);\n            }\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            this.isDrag = false;\n            this.draw(e);\n        };\n        const { ctx, bufferCanvas } = this;\n        this.lastPoint = new Point(0, 0);\n        this.zoomBindObject = this.zoom.bind(this, views.canvas);\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect = new Rect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.focusRect = new Rect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    draw(e) {\n        const { ctx, rasterCanvas, canvas, rasterCtx, bufferCanvas, isDrag: isStart, focusRect } = this;\n        drawCropFiled(ctx, bufferCanvas, rasterCtx, rasterCanvas, isStart, focusRect);\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    resetRect() {\n        const { ctx, bufferCanvas } = this;\n        const transform = ctx.getTransform();\n        const currentZoom = getCurrentZoom(ctx);\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.focusRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n    }\n    zoom(e) {\n        const { ctx, rasterCanvas, canvas, rasterCtx: rasterCtx, bufferCanvas, originalRect, focusRect } = this;\n        const zoom = e.deltaY < 0 ? 1.1 : 0.9;\n        const maxZoom = 15; // maximum zoom level\n        const minZoom = 0.1; // minimum zoom level\n        const currentZoom = getCurrentZoom(ctx); // helper function to get current zoom level\n        // Calculate the new zoom level, making sure it stays within the maximum and minimum bounds\n        const newZoom = Math.min(Math.max(currentZoom * zoom, minZoom), maxZoom);\n        const transform = ctx.getTransform();\n        this.originalRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        const originalWidth = originalRect.right - originalRect.left;\n        const originalHeight = originalRect.bottom - originalRect.top;\n        const dx = originalRect.left - focusRect.left;\n        const dy = originalRect.top - focusRect.top;\n        const scaleX = (originalRect.right - originalRect.left) / (originalRect.right - originalRect.left - dx);\n        const scaleY = (originalRect.bottom - originalRect.top) / (originalRect.bottom - originalRect.top - dy);\n        const scaleFactor = Math.min(scaleX, scaleY);\n        const newWidth = (focusRect.right - focusRect.left) * scaleFactor;\n        const newHeight = (focusRect.bottom - focusRect.top) * scaleFactor;\n        this.focusRect.setRect(transform.e, transform.f, transform.e + bufferCanvas.width * currentZoom, transform.f + bufferCanvas.height * currentZoom);\n        this.draw(e);\n    }\n    cleanCanvas() {\n        this.rasterCtx.clearRect(0, 0, this.rasterCanvas.width, this.rasterCanvas.height);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n        canvas.addEventListener('wheel', this.zoomBindObject);\n        canvas.addEventListener('resize', this.zoomBindObject);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n        canvas.removeEventListener('wheel', this.zoomBindObject);\n        canvas.removeEventListener('resize', this.zoomBindObject);\n        this.cleanCanvas();\n        this.canvas.style.cursor = 'default';\n    }\n}\nexport default CropTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass EraseTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isDrawStart = false;\n        this.setSize = (size) => {\n            this.size = size;\n        };\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isDrawStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n            this.draw(e);\n        };\n        this.mouseMove = (e) => {\n            if (!this.isDrawStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { bufferCtx } = this;\n            this.draw(e);\n            this.isDrawStart = false;\n            bufferCtx.globalCompositeOperation = 'source-over';\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n        this.size = 5;\n    }\n    draw(e) {\n        const { bufferCtx, size, canvas, ctx } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        bufferCtx.beginPath();\n        bufferCtx.globalCompositeOperation = 'destination-out';\n        bufferCtx.moveTo(this.lastPoint.x, this.lastPoint.y);\n        bufferCtx.lineTo(currentTransformedCursor.x, currentTransformedCursor.y);\n        bufferCtx.lineWidth = size;\n        bufferCtx.lineCap = 'round';\n        bufferCtx.stroke();\n        bufferCtx.closePath();\n        this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default EraseTool;\n","import { getTransformedPoints } from '~/utils/canvas/coordinate';\nimport Point from '../Point';\nimport BaseTool from './BaselTool';\nclass PanTool extends BaseTool {\n    constructor(views, stateController, rasterViews) {\n        super(views, stateController, rasterViews);\n        this.isPanStart = false;\n        this.mouseDown = (e) => {\n            e.preventDefault();\n            this.isPanStart = true;\n            const { canvas, ctx } = this;\n            const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n            this.lastPoint.setPoint(currentTransformedCursor.x, currentTransformedCursor.y);\n        };\n        this.mouseMove = (e) => {\n            const { canvas, ctx } = this;\n            e.preventDefault();\n            if (!this.isPanStart)\n                return;\n            this.draw(e);\n        };\n        this.mouseUp = (e) => {\n            e.preventDefault();\n            const { ctx } = this;\n            this.isPanStart = false;\n            super.doCmd();\n        };\n        this.lastPoint = new Point(0, 0);\n    }\n    draw(e) {\n        const { ctx, canvas } = this;\n        const currentTransformedCursor = getTransformedPoints(e, canvas, ctx);\n        ctx.translate(currentTransformedCursor.x - this.lastPoint.x, currentTransformedCursor.y - this.lastPoint.y);\n        super.draw(e);\n    }\n    registerEvent() {\n        const { canvas } = this;\n        canvas.addEventListener('mousedown', this.mouseDown);\n        canvas.addEventListener('mousemove', this.mouseMove);\n        canvas.addEventListener('mouseup', this.mouseUp);\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp);\n    }\n    unRegisterEvent() {\n        const { canvas } = this;\n        canvas.removeEventListener('mousedown', this.mouseDown);\n        canvas.removeEventListener('mousemove', this.mouseMove);\n        canvas.removeEventListener('mouseup', this.mouseUp);\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp);\n    }\n}\nexport default PanTool;\n","import EraseTool from './Erase';\nimport BrushTool from './Brush';\nimport PanTool from './Pan';\nimport CropTool from './Crop';\nexport const Tools = {\n    BrushTool,\n    EraseTool,\n    PanTool,\n    CropTool,\n};\nexport default function dynamicClass(name) {\n    return Tools[name];\n}\n"],"names":[],"sourceRoot":""}