{"version":3,"file":"691e44add122f1e2008c.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;ACVrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACvC2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAgD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kCAAkC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAe,eAAe,EAAC","sources":["webpack://leetcodecrack/./src/canvas/ImageEditor/Point.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/Rect.ts","webpack://leetcodecrack/./src/canvas/ImageEditor/StateController/StateController.ts"],"sourcesContent":["class Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    setPoint(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nexport default Point;\n","class Rect {\n    constructor(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    setRect(left, top, right, bottom) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n    getWidth() {\n        return this.right - this.left;\n    }\n    getHeight() {\n        return this.bottom - this.top;\n    }\n    scaleRect(level) {\n        const width = this.right - this.left;\n        const height = this.bottom - this.top;\n        // Scale the width and height based on the scaleX and scaleY parameters\n        const scaledWidth = width * level;\n        const scaledHeight = height * level;\n        // Calculate the new coordinates for the scaled rectangle\n        const scaledLeft = this.left - (scaledWidth - width) / 2;\n        const scaledTop = this.top - (scaledHeight - height) / 2;\n        const scaledRight = scaledLeft + scaledWidth;\n        const scaledBottom = scaledTop + scaledHeight;\n        this.left = scaledLeft;\n        this.top = scaledTop;\n        this.right = scaledRight;\n        this.bottom = scaledBottom;\n    }\n    IsOverBoundRect(innerLeft, innerTop, innerRight, innerBottom, outerLeft, outerTop, outerRight, outerBottom) {\n        return innerLeft < outerLeft || innerTop < outerTop || innerRight > outerRight || innerBottom > outerBottom;\n    }\n}\nexport default Rect;\n","import { onload2promise } from '~/utils/image';\nclass StateController {\n    constructor() {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.mouseDown = (e) => { };\n        this.mouseMove = (e) => { };\n        this.mouseUp = (e) => { };\n        this.onKeyDown = (e) => {\n            if (e.ctrlKey) {\n                if (e.key === 'z') {\n                    this.undo.apply(this);\n                }\n                if (e.key === 'y') {\n                    this.redo.apply(this);\n                }\n            }\n        };\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    initializeCanvas(views) {\n        this.canvas = views.canvas;\n        this.bufferCanvas = views.bufferCanvas;\n        this.bufferCtx = views.bufferCtx;\n        this.views = views;\n        this.registerEvent(this.canvas);\n    }\n    draw() {\n        const { views } = this;\n        views.draw();\n    }\n    async undo() {\n        const { undoStack, redoStack, bufferCtx, bufferCanvas, views } = this;\n        if (this.undoStack.length <= 1)\n            return;\n        // Remove current state from undo stack and push onto redo stack\n        const currentState = undoStack.pop();\n        redoStack.push(currentState);\n        // Load previous state from undo stack onto canvas\n        const previousState = undoStack[undoStack.length - 1] || currentState;\n        const img = new Image();\n        img.src = previousState;\n        await onload2promise(img);\n        bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);\n        bufferCtx.drawImage(img, 0, 0, bufferCanvas.width, bufferCanvas.height, 0, 0, bufferCanvas.width, bufferCanvas.height);\n        this.draw();\n    }\n    async redo() {\n        const { undoStack, redoStack, bufferCtx, bufferCanvas } = this;\n        if (redoStack.length === 0)\n            return;\n        // Remove current state from redo stack and push onto undo stack\n        const currentState = redoStack.pop();\n        undoStack.push(currentState);\n        // Load next state from redo stack onto canvas\n        const nextImage = new Image();\n        nextImage.src = currentState;\n        await onload2promise(nextImage);\n        bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);\n        bufferCtx.drawImage(nextImage, 0, 0, bufferCanvas.width, bufferCanvas.height, 0, 0, bufferCanvas.width, bufferCanvas.height);\n        this.draw();\n    }\n    cleanState() {\n        this.unRegisterEvent(this.canvas);\n        console.log('cleanState');\n        this.undoStack = [];\n        this.redoStack = [];\n    }\n    pushUndoStack() {\n        const { undoStack, canvas, bufferCanvas } = this;\n        if (bufferCanvas) {\n            undoStack.push(bufferCanvas.toDataURL());\n            this.redoStack = [];\n        }\n    }\n    registerEvent(canvas) {\n        canvas.addEventListener('touchstart', this.mouseDown);\n        canvas.addEventListener('touchmove', this.mouseMove);\n        canvas.addEventListener('touchend', this.mouseUp.bind(this));\n        canvas.addEventListener('mouseup', this.mouseUp.bind(this));\n        window.addEventListener('keydown', this.onKeyDown);\n        // canvas.addEventListener('wheel', this.zoom.bind);\n    }\n    unRegisterEvent(canvas) {\n        canvas.removeEventListener('touchstart', this.mouseDown);\n        canvas.removeEventListener('touchmove', this.mouseMove);\n        canvas.removeEventListener('touchend', this.mouseUp.bind(this));\n        canvas.removeEventListener('mouseup', this.mouseUp.bind(this));\n        window.removeEventListener('keydown', this.onKeyDown);\n        // canvas.removeEventListener('wheel', this.zoom(this));\n    }\n}\nexport default StateController;\n"],"names":[],"sourceRoot":""}