{"version":3,"file":"44d355320407c3dd3033.js","mappings":";;;;;;;;;;;;;;;;AAAiD;AACiD;AAClG;AACA,sBAAsB,6CAAM;AAC5B;AACA,UAAU,8CAA8C;AACxD,UAAU,6CAA6C;AACvD,UAAU,mDAAmD;AAC7D,UAAU,8CAA8C;AACxD,UAAU,2CAA2C;AACrD;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA,oCAAoC,qEAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAoB;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,0DAAmB,aAAa,0BAA0B;AACrE;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;AChFyB;AACwD;AACzG;AACA,sBAAsB,6CAAM;AAC5B;AACA,UAAU,8CAA8C;AACxD,UAAU,6CAA6C;AACvD,UAAU,mDAAmD;AAC7D,UAAU,8CAA8C;AACxD,UAAU,2CAA2C;AACrD;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA,oCAAoC,qEAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mEAAoB;AAC5C;AACA,KAAK;AACL,IAAI,gDAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,wBAAwB,+DAAgB;AACxC;AACA;AACA;AACA,sCAAsC,mEAAoB;AAC1D;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,0DAAmB,aAAa,0BAA0B;AACrE;AACA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;ACpFE;AACyB;AACA;AACnD;AACA,YAAY,0DAAmB,UAAU,sEAAsE;AAC/G,QAAQ,0DAAmB,CAAC,kEAAQ,IAAI,gCAAgC;AACxE,QAAQ,0DAAmB,CAAC,kEAAQ,IAAI,gCAAgC;AACxE;AACA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;;;;;ACRd;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA","sources":["webpack://leetcodecrack/./src/components/Chart/ChartBar.tsx","webpack://leetcodecrack/./src/components/Chart/ChartPie.tsx","webpack://leetcodecrack/./src/pages/Home/Canvas/Chart.tsx","webpack://leetcodecrack/./src/utils/canvas.ts"],"sourcesContent":["import React, { useRef, useEffect } from 'react';\nimport { accumlateOfPercentange, getAngleOfPercentage, drawLine, drawBar, } from '~/utils/canvas';\nconst ChartBar = (props) => {\n    const canvasRef = useRef(null);\n    const results = [\n        { mood: 'Angry', total: 1499, color: '#0a9627' },\n        { mood: 'Happy', total: 478, color: '#960A2C' },\n        { mood: 'Melancholic', total: 332, color: '#332E2E' },\n        { mood: 'Gloomy', total: 195, color: '#F73809' },\n        { mood: 'Gloomy', total: 195, color: 'pink' },\n    ];\n    let totalNumber = results.reduce((sum, { total }) => sum + total, 0);\n    let lastValue = 0;\n    const datas = results.map((result) => {\n        const lastPercentage = (lastValue / totalNumber) * 100;\n        const accumlatePercentage = accumlateOfPercentange(result.total, lastPercentage, totalNumber);\n        lastValue += result.total;\n        return {\n            accumlatePercentage: accumlatePercentage,\n            percentage: Math.round((result.total / totalNumber) * 100),\n            data: result.total,\n            color: result.color,\n            startAngle: getAngleOfPercentage(lastPercentage),\n        };\n    });\n    const options = {\n        padding: 30,\n        gridColor: 'white',\n        gridScale: 300,\n        data: datas,\n        spaceScale: 2,\n    };\n    useEffect(() => {\n        let maxValue = 2000;\n        if (canvasRef.current) {\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            let cw = (canvas.width = canvasRef.current.clientWidth);\n            let ch = (canvas.height = canvasRef.current.clientHeight);\n            function drawGridLines() {\n                let canvasActualHeight = ch - options.padding * 2;\n                let canvasActualWidth = cw - options.padding * 2;\n                let gridValue = 0;\n                while (gridValue <= maxValue) {\n                    var gridY = canvasActualHeight * (1 - gridValue / maxValue) + options.padding;\n                    drawLine(ctx, 0, gridY, canvas.width, gridY, options.gridColor);\n                    drawLine(ctx, options.padding / 2, options.padding / 2, options.padding / 2, gridY + options.padding / 2, options.gridColor);\n                    // Writing grid markers\n                    ctx.save();\n                    ctx.fillStyle = options.gridColor;\n                    ctx.textBaseline = 'bottom';\n                    ctx.font = 'bold 10px Arial';\n                    ctx.fillText(String(gridValue), +20, gridY - 2);\n                    ctx.restore();\n                    gridValue += options.gridScale;\n                }\n            }\n            function drawBars() {\n                let canvasActualWidth = cw - options.padding * 2;\n                let canvasActualHeight = ch - options.padding * 2;\n                let barIndex = 0;\n                let numberOfBars = Object.keys(options.data).length;\n                let baseBarSize = canvasActualWidth / numberOfBars / options.spaceScale;\n                let barSize = baseBarSize;\n                let space = barSize / 2;\n                let values = Object.values(options.data);\n                for (const [i, val] of values.entries()) {\n                    let barHeight = Math.round((canvasActualHeight * val.data) / maxValue);\n                    let leftSpace = space * (i + 1);\n                    let rightSpace = space * i;\n                    drawBar(ctx, options.padding + barIndex * barSize + leftSpace + rightSpace, canvas.height - barHeight - options.padding, barSize, barHeight, val.color);\n                    barIndex++;\n                }\n            }\n            drawBars();\n            drawGridLines();\n        }\n    }, []);\n    return React.createElement(\"canvas\", { ...props, ref: canvasRef });\n};\nexport default ChartBar;\n","import React, { useRef, useEffect } from 'react';\nimport { drawPie, drawSegmentLabel, accumlateOfPercentange, getAngleOfPercentage } from '~/utils/canvas';\nconst ChartPie = (props) => {\n    const canvasRef = useRef(null);\n    const results = [\n        { mood: 'Angry', total: 1499, color: '#0a9627' },\n        { mood: 'Happy', total: 478, color: '#960A2C' },\n        { mood: 'Melancholic', total: 332, color: '#332E2E' },\n        { mood: 'Gloomy', total: 195, color: '#F73809' },\n        { mood: 'Gloomy', total: 195, color: 'pink' },\n    ];\n    let totalNumber = results.reduce((sum, { total }) => sum + total, 0);\n    let lastValue = 0;\n    const datas = results.map((result) => {\n        const lastPercentage = (lastValue / totalNumber) * 100;\n        const accumlatePercentage = accumlateOfPercentange(result.total, lastPercentage, totalNumber);\n        lastValue += result.total;\n        return {\n            accumlatePercentage: accumlatePercentage,\n            percentage: Math.round((result.total / totalNumber) * 100),\n            data: result.total,\n            color: result.color,\n            startAngle: getAngleOfPercentage(lastPercentage),\n        };\n    });\n    useEffect(() => {\n        if (canvasRef.current) {\n            const canvas = canvasRef.current;\n            const ctx = canvas.getContext('2d');\n            let cw = (canvas.width = canvasRef.current.clientWidth);\n            let ch = (canvas.height = canvasRef.current.clientHeight);\n            // ctx.fillStyle = 'white';\n            // ctx.fillRect(0, 0, canvas.width, canvas.height);\n            let endingPct = 100;\n            let radius = canvasRef.current.clientWidth / 4;\n            let pct = 0;\n            let cx = Math.ceil(cw / 2);\n            let cy = Math.ceil(ch / 2);\n            // let img = new Image();\n            // img.onload = start;\n            // img.src = require('~/assets/img/me.jpg');\n            function start() {\n                requestAnimationFrame(animate);\n            }\n            function animate(time) {\n                draw(pct);\n                pct++;\n                if (pct <= endingPct) {\n                    requestAnimationFrame(animate);\n                }\n            }\n            function draw(pct) {\n                var endRadians = -Math.PI / 2 + (Math.PI * 2 * pct) / 100;\n                for (const [index, moodValue] of datas.entries()) {\n                    ctx.fillStyle = moodValue.color;\n                    if (endRadians >= moodValue.startAngle && pct <= moodValue.accumlatePercentage) {\n                        if (moodValue.color === '#0a9627') {\n                            // debugger;\n                        }\n                        drawPie(ctx, {\n                            radius,\n                            startAngle: moodValue.startAngle,\n                            endAngle: endRadians,\n                            cx,\n                            cy,\n                            color: moodValue.color,\n                        });\n                        drawSegmentLabel(ctx, {\n                            cx,\n                            cy,\n                            startAngle: moodValue.startAngle,\n                            endAngle: getAngleOfPercentage(moodValue.accumlatePercentage),\n                            radius,\n                            percentage: moodValue.accumlatePercentage,\n                            text: String(moodValue.percentage),\n                        });\n                    }\n                }\n            }\n            start();\n        }\n    }, []);\n    return React.createElement(\"canvas\", { ...props, ref: canvasRef });\n};\nexport default ChartPie;\n","import React from 'react';\nimport ChartBar from '~/components/Chart/ChartBar';\nimport ChartPie from '~/components/Chart/ChartPie';\nconst Chart = () => {\n    return (React.createElement(\"div\", { className: \"m-auto flex w-full flex-col items-center justify-center\" },\n        React.createElement(ChartPie, { className: \"h-[50vh] w-[50vh]\" }),\n        React.createElement(ChartBar, { className: \"h-[50vh] w-[50vh]\" })));\n};\nexport default Chart;\n","export function drawSegmentLabel(ctx, dto) {\n    const centerDistance = 0.5;\n    ctx.beginPath();\n    ctx.font = '20px Arial';\n    ctx.textAlign = 'center';\n    ctx.fillStyle = 'white';\n    let theta = (dto.startAngle + dto.endAngle) / 2;\n    let deltaY = Math.ceil(Math.sin(theta) * centerDistance * dto.radius);\n    let deltaX = Math.ceil(Math.cos(theta) * centerDistance * dto.radius);\n    ctx.fillText(dto.text, deltaX + dto.cx, deltaY + dto.cy);\n    ctx.closePath();\n}\nexport function drawPie(ctx, dto) {\n    const strokeWidth = 2;\n    ctx.beginPath();\n    ctx.arc(dto.cx, dto.cy, dto.radius, dto.startAngle, dto.endAngle);\n    ctx.lineWidth = strokeWidth;\n    ctx.lineTo(dto.cx, dto.cy);\n    ctx.closePath();\n    ctx.save();\n    ctx.clip();\n    ctx.fillStyle = dto.color;\n    ctx.fill();\n    ctx.lineWidth = strokeWidth;\n    ctx.strokeStyle = 'black';\n    ctx.stroke();\n    ctx.restore();\n}\nexport function drawLine(ctx, startX, startY, endX, endY, color) {\n    ctx.save();\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(startX, startY);\n    ctx.lineTo(endX, endY);\n    ctx.stroke();\n    ctx.restore();\n}\nexport function drawBar(ctx, upperLeftCornerX, upperLeftCornerY, width, height, color) {\n    ctx.save();\n    ctx.fillStyle = color;\n    ctx.fillRect(upperLeftCornerX, upperLeftCornerY, width, height);\n    ctx.restore();\n}\nexport const getAngleOfPercentage = (percentage) => {\n    return -Math.PI / 2 + (Math.PI * 2 * percentage) / 100;\n};\nexport const accumlateOfPercentange = (data, percentage, totalNumber) => {\n    return Math.ceil(percentage + (data / totalNumber) * 100);\n};\n"],"names":[],"sourceRoot":""}